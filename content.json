{"meta":{"title":"TKVERN BLOG","subtitle":"Developer & Designer","description":"Developer & Designer. Believe what you believe, and stick to what you insist on.","author":"TKVERN","url":"https://tkvern.com"},"pages":[{"title":"About","date":"2016-04-19T14:55:40.000Z","updated":"2023-01-20T15:23:47.000Z","comments":false,"path":"about/index.html","permalink":"https://tkvern.com/about/index.html","excerpt":"","text":"IntroduceEnglish Name: Vern Brandl.Location: ShenZhen, China.Group: EIMS.Motto: Believe what you believe, and stick to what you insist on.Work: Front-end &amp; Ruby on Rails engineer &amp; Node.js engineer Time Line 1995 Born in China. 2010 The first line of code by C. 2012 Audio China Forum was born. 2014 Mould Cloud online for Haier. 2015 Upgrade Rhino Cloud and Mobile Enterprise Show online. Contribution front component autostrap. 2016 Contribution gem package wysiwyg-rails-qiniu. Using Hexo for blog"},{"title":"categories","date":"2016-04-19T15:05:49.000Z","updated":"2023-01-20T15:23:47.000Z","comments":false,"path":"categories/index.html","permalink":"https://tkvern.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-04-19T15:06:55.000Z","updated":"2023-01-20T15:23:47.000Z","comments":false,"path":"tags/index.html","permalink":"https://tkvern.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"烟火","slug":"烟火","date":"2023-01-13T21:42:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20230113/烟火/","link":"","permalink":"https://tkvern.com/20230113/烟火/","excerpt":"今晨早起，记昨夜放烟花杂事有感","text":"今晨早起，记昨夜放烟花杂事有感 烟火张翔不知天上逍遥仙可食人间烟火味倘若仙途有来路不念凡尘飞升去","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"小米路由器 SSH密码根据SN破解","slug":"小米路由器 SSH密码根据SN破解","date":"2022-05-07T03:25:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20220507/小米路由器 SSH密码根据SN破解/","link":"","permalink":"https://tkvern.com/20220507/小米路由器 SSH密码根据SN破解/","excerpt":"写了个 Node.js 命令行版的，测试了一下，和官方给出的 SSH 密码一样。","text":"写了个 Node.js 命令行版的，测试了一下，和官方给出的 SSH 密码一样。 源码如下:123456789101112131415161718192021222324252627282930const Crypto = require('crypto');var salt = &#123; 'r1d': 'A2E371B0-B34B-48A5-8C40-A7133F3B5D88', 'others': 'd44fb0960aa0-a5e6-4a30-250f-6d2df50a'&#125;function getPasswd(sn) &#123; var md5 = Crypto.createHash('md5'); const hex = md5.update(sn + getSalt(sn)).digest('hex') return hex.substring(0, 8);&#125;function getSalt(sn) &#123; if (sn.includes('/')) &#123; return swapSalt(salt['others']); &#125; else &#123; return salt['r1d']; &#125;&#125;function swapSalt(s) &#123; return s.split('-').reverse().join('-');&#125;const SN = process.argv[2]console.log(`Usage: $&#123;SN&#125; SN` )const passwd = getPasswd(SN)console.log('decrypt password:', passwd) 使用方法 复制代码到文件，index.js 命令行运行代码 123$ node index.js 36418/K1WW04216Usage: 36418/K1WW04216 SNdecrypt password: f25b355a 登录到路由器，没有ssh的，先sudo apt-get install ssh 用户名：root 密码：f25b355a 看到 ARE U OK即破解成功","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}],"tags":[],"keywords":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}]},{"title":"记得我有一个女朋友","slug":"记得我有一个女朋友","date":"2021-11-06T04:32:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20211106/记得我有一个女朋友/","link":"","permalink":"https://tkvern.com/20211106/记得我有一个女朋友/","excerpt":"(Cover 我有一个男朋友)","text":"(Cover 我有一个男朋友) 记得我有一个女朋友张翔记得我有一个女朋友她会时常偷偷看我的眼眸举她起来也不会觉得费手给她讲梦里的浪漫星球记得我有一个女朋友下雨天的约会是在她家门口酒吧鼓手敲着周五下班的节奏爵士加一杯果汁也会上头记得我有一个女朋友那是我们还养着一只雪白色的大狗取了个可爱的名字叫妞妞笑我幼稚我总会说你很欠揍记得我有一个女朋友她总开心跟我一起吃肉肉吃得白白胖胖还有点变丑可在我的眼里依然温柔记得我有一个女朋友我会晚上带她去看脱口秀她总吹牛自己有多能喝酒醉到怀里总还要啃我几口记得我有一个女朋友也许我会问她是否愿意到白头无论健康疾病或贫穷富有这时戴上戒指我说与子携手可是呀我们已经分开好久","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"故里街三十二号","slug":"故里街三十二号","date":"2021-08-27T18:20:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20210827/故里街三十二号/","link":"","permalink":"https://tkvern.com/20210827/故里街三十二号/","excerpt":"又回到故里街，仍是故里街，不见故里人","text":"又回到故里街，仍是故里街，不见故里人 故里街三十二号张翔夜里的灯还亮着歌还唱着城市的人还没回家呢到故里的末班车有多少人等到了梦一场的故事还述说着喝醉的姑娘你的家在哪里呢是离家太远等不到故里的车么喝杯故里的酒一杯敬过往一杯敬明天往事都如烟听首故里的歌一首唱过往一首唱明天往后都开心写行故里的诗一行写过往一行写明天往事不牵连爱个故里的人一个在过往一个在明天夜里说晚安","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"观海栈桥","slug":"观海栈桥","date":"2021-08-19T05:19:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20210819/观海栈桥/","link":"","permalink":"https://tkvern.com/20210819/观海栈桥/","excerpt":"未完，观海栈桥是一个地名。","text":"未完，观海栈桥是一个地名。 观海栈桥张翔那一晚星光灿烂风儿撩拨海浪握着你的手温暖 柔软这一首琴声悠然月儿陶醉梦乡拥入我怀抱酥香 芬芳有一个银河幻想你和我在徜徉河里留下的是爱的 模样","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"三行情诗","slug":"三行情诗","date":"2021-08-14T06:13:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20210814/三行情诗/","link":"","permalink":"https://tkvern.com/20210814/三行情诗/","excerpt":"今日中国七夕情人节，送一首情诗（杨辉三角）","text":"今日中国七夕情人节，送一首情诗（杨辉三角） 三行情诗张翔这行是你这行是你这行依旧是你","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"就忘记","slug":"就忘记","date":"2021-08-10T08:11:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20210810/就忘记/","link":"","permalink":"https://tkvern.com/20210810/就忘记/","excerpt":"有时候不经意的人或事，又会想起关于她的，好多记忆，好多画面。好与坏都是生命体验的一部分，就开始的新生活吧。（写得不太好，后半段烂尾了😭，缺少一些画面和情感的融合）作于深圳，2021-08-10 16:11 笔 2021-08-17 20:24 更新，有了新的思路，把后半段的画面补上了","text":"有时候不经意的人或事，又会想起关于她的，好多记忆，好多画面。好与坏都是生命体验的一部分，就开始的新生活吧。（写得不太好，后半段烂尾了😭，缺少一些画面和情感的融合）作于深圳，2021-08-10 16:11 笔 2021-08-17 20:24 更新，有了新的思路，把后半段的画面补上了 就忘记张翔思念有多长分开有多难拉拉扯扯的画面就留着回忆吧我不在的以后有些伤痛 醒来就忘了吧要像个孩子一样快乐呀最近还好吗你新的生活喜怒哀乐的细节都有人分享吧我不在的以后有些快乐 就永远记着吧要像第一次见你那样呀让工作把我的时间占据不再思考关于你的情绪让时间把我的记忆抹去不再回忆关于你的过去夜里的想念就留给自己不再查看关于你的消息往后的日子也留给自己就忘记关于你的点点滴滴去填满心的每一道缝隙","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"让你的文字自动适配背景颜色","slug":"让你的文字自动适配背景颜色","date":"2021-02-24T16:00:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20210224/让你的文字自动适配背景颜色/","link":"","permalink":"https://tkvern.com/20210224/让你的文字自动适配背景颜色/","excerpt":"网传，产品经理要求App开发人员，让用户App的主题颜色能根据手机壳自动调整。 刚好笔者要做一个类似的事情，根据背景颜色自动改变文字的颜色，以便于用户识别。","text":"网传，产品经理要求App开发人员，让用户App的主题颜色能根据手机壳自动调整。 刚好笔者要做一个类似的事情，根据背景颜色自动改变文字的颜色，以便于用户识别。 正文产品设计了一个人机校验组件，大致长这个样子。背景会每次随机取不同图片，开始的时候，箭头设置为蓝色。在背景为蓝色的时候，用户就分辨箭头就有些困难了。怎么解决这个问题呢？ 思路与实现第一步取到箭头底部背景的范围坐标。这个比较简单，基本运算就搞定，done 第二步要识别图片，我们需要借助 Canvas，将图片绘制到 Canvas 上，来操作图像数据。 创建 Canvas 容器1234const c4 = document.createElement('canvas')c4.width = 190c4.height = 190const ctx4 = c4.getContext('2d') 放入图片12345678910// 识别图片const image = new Image()image.onload = () =&gt; &#123; ctx4?.drawImage(image, 0, 0, 191, 190) // 绘制图片到 Canvas const color = analysisColor(ctx4?.getImageData(0, 0, 191, 190)) // 分析颜色分布 setFontColor(color) // 设置字体颜色 resolve(true) // 完成Promise&#125;image.src = images[`code-$&#123;index&#125;`] // 取本次随机图片的地址设置到 image 跨域问题可是进展并没有那么顺利，背景图片不在同域下面，Canvas 不允许跨域的图片，怎么办呢？ 第三步既然 Canvas 不允许跨域的图片，在无后端代理支持的情况下，怎么高效的解决这个问题呢？(本地是跨域，线上同域) 把图片下载的本地！借助 XMLHttpRequest 将图片先缓存到本地转成 Blob 对象，Canvas 是可以访问本地 Blob 的数据。 下载图片，解决图片跨域问题1234567891011// 下载图片，解决图片跨域问题const xhr = new XMLHttpRequest()xhr.open('get', images[`code-$&#123;index&#125;`], true)xhr.responseType = 'blob'xhr.onload = function loaded() &#123; if (this.status === 200) &#123; const blob = this.response image.src = window.URL.createObjectURL(blob) &#125;&#125;xhr.send() 第四步解决了跨域问题，接下来就是分析颜色了，getImageData 取到的就是图片 rgba 的数组。这个时候就可以将计算好的坐标，代入到图片 rgba 里面计算其分布。 说到这里就要补一下图像算法的知识了。 许多从自然场景中拍摄的图像，其色彩分布上会给人一种和谐、一致的感觉；反过来，在许多界面设计应用中，我们也希望选择的颜色可以达到这样的效果，但对一般人来说却并不那么容易，这属于色彩心理学的范畴。从彩色图像中提取其中的主题颜色，不仅可以用于色彩设计，也可用于图像分类、搜索、识别等，本文分别总结并实现图像主题颜色提取的几种算法，包括颜色量化法（ColorQuantization）、聚类(Clustering)和颜色建模的方法 颜色量化算法彩色图像一般采用RGB色彩模式，每个像素由RGB三个颜色分量组成。随着硬件的不断升级，彩色图像的存储由最初的8位、16位变成现在的24位、32真彩色。所谓全彩是指每个像素由8位（$2^8$=0~255）表示，红绿蓝三原色组合共有1677万（256 x 256 x 256 ）万种颜色，如果将RGB看作是三维空间中的三个坐标，可以得到下面这样一张色彩空间图： RGB color cube 当然，一张图像不可能包含所有颜色，我们将一张彩色图像所包含的像素投射到色彩空间中，可以更直观地感受图像中颜色的分布： 因此颜色量化问题可以用所有矢量量化（vector quantization, VQ）算法解决。这里采用开源图像处理库 Leptonica 中用到的两种算法：中位切分法、八叉树算法。 这里核心使用中位切分法（Median cut） 参考项目 Github: color-thief 1234// 计算图片中间值function analysisColor(rgbaArray: any) &#123; // Todo something，返回该区域颜色的主色&#125; 第五步到这里，这个需求就算实现了基本核心的部分了，但是在运行过程中，发现性能消耗极大。大部分花在了 Canvas 绘制和图像遍历上 怎么来优化这个过程呢？能不能只提取图像的特征信息进行分析呢？ 带着这两个问题，查阅了图像特征算法相关的文献后，找到了 方向梯度直方图（Histogram of Oriented Gradient, HOG） 这个算法。 基HOG特征方向梯度直方图（Histogram of Oriented Gradient, HOG）特征是一种在计算机视觉和图像处理中用来进行物体检测的特征描述子。它通过计算和统计图像局部区域的梯度方向直方图来构成特征。Hog特征结合 SVM分类器已经被广泛应用于图像识别中，尤其在行人检测中获得了极大的成功。需要提醒的是，HOG+SVM进行行人检测的方法是法国研究人员Dalal 在2005的CVPR上提出的，而如今虽然有很多行人检测算法不断提出，但基本都是以HOG+SVM的思路为主。 主要思想在一副图像中，局部目标的表象和形状（appearance and shape）能够被梯度或边缘的方向密度分布很好地描述。（本质：梯度的统计信息，而梯度主要存在于边缘的地方）。 具体的实现方法是首先将图像分成小的连通区域，我们把它叫细胞单元。然后采集细胞单元中各像素点的梯度的或边缘的方向直方图。最后把这些直方图组合起来就可以构成特征描述器。 提高性能把这些局部直方图在图像的更大的范围内（我们把它叫区间或block）进行对比度归一化（contrast-normalized），所采用的方 法是：先计算各直方图在这个区间（block）中的密度，然后根据这个密度对区间中的各个细胞单元做归一化。通过这个归一化后，能对光照变化和阴影获得更 好的效果。 优点与其他的特征描述方法相比，HOG有很多优点。首先，由于HOG是在图像的局部方格单元上操作，所以它对图像几何的和光学的形变都能保持很好的不 变性，这两种形变只会出现在更大的空间领域上。其次，在粗的空域抽样、精细的方向抽样以及较强的局部光学归一化等条件下，只要行人大体上能够保持直立的姿 势，可以容许行人有一些细微的肢体动作，这些细微的动作可以被忽略而不影响检测效果。因此HOG特征是特别适合于做图像中的人体检测的。 HOG特征提取算法的实现过程 第六步基于此，来做我们自己的算法实现。将原图在绘制时，按照等比平铺，一步步的绘制到 Canvas 格子上去。随着尺寸的缩小，图像的特征依然得以保留，大致效果如下。 在实验多个不同的压缩尺寸后，发现 16x16 这个尺寸能兼顾特征与识别性能，再小一些的格子比如 8x8 就会丢失特征值。 贴一下大致的实现过程1234567891011121314151617181920212223242526272829303132333435const checkBack = async (index: number) =&gt; &#123; return new Promise((resolve) =&gt; &#123; // 计算图片中间值 function analysisColor(rgbaArray: any) &#123; // Todo something，返回该区域颜色的主色 &#125; const c4 = document.createElement('canvas') // 压缩尺寸计算用 c4.width = 16 c4.height = 16 const ctx4 = c4.getContext('2d') // 识别图片 const image = new Image() image.onload = () =&gt; &#123; ctx4?.drawImage(image, 0, 0, 17, 16) // 绘制图片到 Canvas const color = analysisColor(ctx4?.getImageData(0, 0, 17, 16)) // 分析颜色分布 setFontColor(color) // 设置字体颜色 resolve(true) // 完成Promise &#125; // 下载图片，解决图片跨域问题 const xhr = new XMLHttpRequest() xhr.open('get', images[`code-$&#123;index&#125;`], true) xhr.responseType = 'blob' xhr.onload = function loaded() &#123; if (this.status === 200) &#123; const blob = this.response image.src = window.URL.createObjectURL(blob) console.log(image.src) &#125; &#125; xhr.send() &#125;) &#125; 最后我们再来看看优化后，分析过程的耗时，差不多提升了 100 倍的速度！！！ 最终的效果图:","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}],"tags":[],"keywords":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}]},{"title":"丑奴儿","slug":"丑奴儿","date":"2021-02-12T15:30:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20210212/丑奴儿/","link":"","permalink":"https://tkvern.com/20210212/丑奴儿/","excerpt":"词牌《丑奴儿》，这是一首写在深夜的词，春节短暂相聚即将分离，表达离别的千愁万绪，作此诗于佛山， 2021-02-12 23:30 笔","text":"词牌《丑奴儿》，这是一首写在深夜的词，春节短暂相聚即将分离，表达离别的千愁万绪，作此诗于佛山， 2021-02-12 23:30 笔 丑奴儿张翔年幼未尝愁滋味不说离愁但有离愁适逢别时上心头而今尝尽愁滋味不说愁绪但有愁绪旧瓶新酒杯莫拒","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"下雨容易想你","slug":"下雨容易想你","date":"2021-02-10T17:30:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20210210/下雨容易想你/","link":"","permalink":"https://tkvern.com/20210210/下雨容易想你/","excerpt":"下雨容易想你，作于佛山","text":"下雨容易想你，作于佛山 下雨容易想你张翔分开多久了也没有再联系也不再有你的动态和消息偶尔也还是会想起你想你的时候就会写写关于你的歌曲安静的夜里窗外下着雨可能下雨的天气比较容易想起你潮湿的街区谁还没回去可能回家的距离还差一个你你说我不够爱你不够成熟的交出自己而我们的相遇是不在对的时机你追问一个答案我是不是真的爱你是真的爱你","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"中间人","slug":"中间人","date":"2021-02-05T17:57:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20210205/中间人/","link":"","permalink":"https://tkvern.com/20210205/中间人/","excerpt":"饮酒高歌深夜，记下朋友的胡言真心话，作于深圳","text":"饮酒高歌深夜，记下朋友的胡言真心话，作于深圳 中间人张翔这夜里的故事很多这世界也难以揣度你说在你身边的人不是你爱的人这感觉像是陌生的我也不懂你心里的难过这时刻是人生经历的折磨我不愿你进这火坑可你朋友圈述说着不快乐可能你也是在恨我我不想成为中间人怕你会怪我怕你会真爱的不是她每一次天亮的时候不想你坠入深渊爱河人就是这么奇怪","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"这一夜","slug":"这一夜","date":"2021-02-05T17:55:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20210205/这一夜/","link":"","permalink":"https://tkvern.com/20210205/这一夜/","excerpt":"饮酒高歌深夜，记下朋友的胡言真心话，作于深圳","text":"饮酒高歌深夜，记下朋友的胡言真心话，作于深圳 这一夜张翔这一夜不眠不休怕陷入这一段爱的过程不想再一次进入这情分酒馆的灯火照不亮你的面容再见见你最后一面没有故事的山再无法牵你的手这一杯茶的的味道不记得一开始关于你的是棋再没有关于你的消息可能是表白的时机不期再不见你温柔的气不想再见你的笑脸不想再做卑微的棋","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"夜归・上集","slug":"夜归上集","date":"2020-12-05T05:39:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20201205/夜归上集/","link":"","permalink":"https://tkvern.com/20201205/夜归上集/","excerpt":"昨夜晚归家，作《夜归》上集，作此诗于深圳，2020-12-05 13:39 笔","text":"昨夜晚归家，作《夜归》上集，作此诗于深圳，2020-12-05 13:39 笔 夜归・上张翔月下有寒影风吹归路人长有檐角灯照入深巷里门前守夜人紧衣御长夜掩窗点炉火幽梦还乡来","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"忆卿","slug":"忆卿","date":"2020-12-03T16:10:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20201203/忆卿/","link":"","permalink":"https://tkvern.com/20201203/忆卿/","excerpt":"忆卿时，作于深圳，2020-12-04 00:10 笔","text":"忆卿时，作于深圳，2020-12-04 00:10 笔 忆卿张翔别忆卿时态梦画妆容前但闻细虫声似有万语言","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"苍穹","slug":"苍穹","date":"2020-06-11T15:30:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20200611/苍穹/","link":"","permalink":"https://tkvern.com/20200611/苍穹/","excerpt":"观苍穹之下，作于深圳，2020-06-11 23:30 笔","text":"观苍穹之下，作于深圳，2020-06-11 23:30 笔 苍穹张翔渺渺苍穹外浩瀚星河中浮生若尘埃流光皆微茫孤坐夜幕下纹刻青石上谓生欲何求百学以冥索","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"雨","slug":"雨","date":"2020-05-28T17:33:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20200528/雨/","link":"","permalink":"https://tkvern.com/20200528/雨/","excerpt":"关于雨的一首诗，作此诗于深圳，2020-05-29 01:33 笔","text":"关于雨的一首诗，作此诗于深圳，2020-05-29 01:33 笔 雨张翔垂帘听风易四月初暮雨淅淅沥沥轻寒不知时限行踪无定离君不问归期烟柳画桥卿作桥边客碧波花舫予是泛舟人醉卧十里酒香不及远方不及卿 注释【行踪无定】各处来往出没，没有固定住所【桥边客】往往桥边客，金犹恨未平","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"用deno构建HTTP服务器试试","slug":"用deno构建HTTP服务器试试","date":"2020-04-01T12:26:16.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20200401/用deno构建HTTP服务器试试/","link":"","permalink":"https://tkvern.com/20200401/用deno构建HTTP服务器试试/","excerpt":"恰巧今日有朋友聊到deno，学习了下deno，顺手写了个小玩具。(内容一会再补充……)前端工程师无缝入手。","text":"恰巧今日有朋友聊到deno，学习了下deno，顺手写了个小玩具。(内容一会再补充……)前端工程师无缝入手。 12345678910111213141516171819202122232425262728import &#123; serve &#125; from \"https://deno.land/std@v0.36.0/http/server.ts\";const server = serve(&#123; port: 8899 &#125;);const CONTENT_TYPE_MAP: &#123; [index: string]: any &#125; = &#123; // 定义Content-Type的HashMap html: \"text/html; charset=UTF-8\", htm: \"text/html; charset=UTF-8\", js: \"application/javascript; charset=UTF-8\", css: \"text/css; charset=UTF-8\", txt: \"text/plain; charset=UTF-8\", mainfest: \"text/plain; charset=UTF-8\"&#125;;(async function () &#123; for await (const req of server) &#123; const pathname = req.url.split('?')[0] const filename = '/Users/vernbrandl/Downloads/' + pathname.substring(1); const suffix = filename.substring(filename.lastIndexOf(\".\") + 1); // 获取文件后缀 try &#123; const content = await Deno.readFile(filename) const headers = new Headers(&#123; \"Content-Type\": CONTENT_TYPE_MAP[suffix] || \"application/octet-stream\" &#125;) req.respond(&#123; body: content, status: 200, headers &#125;); &#125; catch (error) &#123; req.respond(&#123; body: \"Not Found\\n\", status: 404 &#125;); &#125; &#125;&#125;)() 项目地址 =&gt; https://github.com/tkvern/deno-http-server","categories":[],"tags":[],"keywords":[]},{"title":"30行代码构建HTTP服务器","slug":"30行代码构建HTTP服务器","date":"2020-03-24T11:50:56.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20200324/30行代码构建HTTP服务器/","link":"","permalink":"https://tkvern.com/20200324/30行代码构建HTTP服务器/","excerpt":"前两天调代码，想查看测试覆盖率生成的网页报告文件，没有安装HTTP服务器客户端。就在VS Code中下载一个叫Live Server的插件，用来启动HTTP服务。感觉效果还不错，然后今天和大家用Node来实现一个。","text":"前两天调代码，想查看测试覆盖率生成的网页报告文件，没有安装HTTP服务器客户端。就在VS Code中下载一个叫Live Server的插件，用来启动HTTP服务。感觉效果还不错，然后今天和大家用Node来实现一个。 开始构建HTTP服务，需要先了解一下HTTP协议的基础知识 HTTP工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 HTTP请求格式 HTTP响应格式 编码这里的需求比较简单，只要能GET即可，不需要POST 这里会用到Node的http和fs模块 导入模块 12const http = require(\"http\");const fs = require(\"fs\"); 创建服务 12const server = http.createServer(); // 创建服务server.listen(8888); // 监听端口 Content-Type的HashMap 这里定义了我们网页中，常用的一些文件类型 12345678const CONTENT_TYPE_MAP = &#123; // 定义Content-Type的HashMap html: \"text/html; charset=UTF-8\", htm: \"text/html; charset=UTF-8\", js: \"application/javascript; charset=UTF-8\", css: \"text/css; charset=UTF-8\", txt: \"text/plain; charset=UTF-8\", mainfest: \"text/plain; charset=UTF-8\"&#125;; 处理Request 在返回response的时候，如果文件类型在CONTENT_TYPE_MAP中没有，我们则以application/octet-stream类型返回，浏览器端会直接将文件下载到本地。 12345678910111213141516171819server.on(\"request\", function(request, response) &#123; const url = require(\"url\").parse(request.url); const filename = url.pathname.substring(1); const suffix = filename.substring(filename.lastIndexOf(\".\") + 1); // 获取文件后缀 fs.readFile(filename, function(err, content) &#123; if (err) &#123; response.writeHead(404, &#123; \"Content-Type\": \"text/plain; charset=UTF-8\" &#125;); response.write(err.message); &#125; else &#123; response.writeHead(200, &#123; \"Content-Type\": CONTENT_TYPE_MAP[suffix] || \"application/octet-stream\" &#125;); response.write(content); &#125; response.end(); &#125;);&#125;); 到这里，借助Node V8引擎，一个极为轻量化、性能优异的基础HTTP服务器就开发完成了。需要本地启动HTTP服务器的时候，再也不用到网上下载啥客户端了，30行代码就搞定。需要的时候，直接命令行启动即可。 项目源码请访问: https://github.com/tkvern/node-http-server","categories":[],"tags":[],"keywords":[]},{"title":"用余弦定理+大数据找到心仪的对象","slug":"用余弦定理+大数据找到心仪的对象","date":"2020-03-23T14:16:11.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20200323/用余弦定理+大数据找到心仪的对象/","link":"","permalink":"https://tkvern.com/20200323/用余弦定理+大数据找到心仪的对象/","excerpt":"前言余弦定理和找对象似乎是两件八杆子打不着的事，但是它们却有着类似于余弦定理和Google的新闻自动分类一样的紧密联系。具体来说，找对象也可以和做Google的新闻自动分类一样，找到最契合的另一半。","text":"前言余弦定理和找对象似乎是两件八杆子打不着的事，但是它们却有着类似于余弦定理和Google的新闻自动分类一样的紧密联系。具体来说，找对象也可以和做Google的新闻自动分类一样，找到最契合的另一半。 原理找对象之前，先来看看文章自动分类的原理，我们做文章自动分类时，第一步是从分词入手 第一步，分词这里使用了一个Node.js比较成熟的分词库，底层算法是基于c++做的实现，性能不错。 参见 /index.js#L88 123456789/** * 简单分词 * @param &#123;String&#125; text 文本 * @returns &#123;Array&#125; */segment(text) &#123; if (!text) return [] return nodejieba.cut(text)&#125; 第二步， 列出所有词分词之后我们将得到所有的词 参见 /index.js#L11 1234567891011/** * 文本相似度查询 * @param &#123;String&#125; textA 文本A * @param &#123;String&#125; textB 文本B */constructor(textA, textB) &#123; textA = \"\" + textA textB = \"\" + textB this.segmentWordsA = this.segment(textA) this.segmentWordsB = this.segment(textB)&#125; 第三步，统计词频率当我们拿到所有词的数组后，还需要进行词频统计，EXCLUDE_WORDS_ARRAY这个是我们排出的一些语气助词。 参见 /index.js#L43 1234567891011121314151617181920212223242526/** * 分析两段文本 */analyse() &#123; // 分析A片段 this.segmentWordsA.forEach(element =&gt; &#123; if (!this.EXCLUDE_WORDS_ARRAY.includes(element)) &#123; if (!this.distributionWordsArray.hasOwnProperty(element)) &#123; this.distributionWordsArray[element] = [1, 0] &#125; else &#123; this.distributionWordsArray[element][0] += 1 &#125; &#125; &#125;) // 分析B片段 this.segmentWordsB.forEach(element =&gt; &#123; if (!this.EXCLUDE_WORDS_ARRAY.includes(element)) &#123; if (!this.distributionWordsArray.hasOwnProperty(element)) &#123; this.distributionWordsArray[element] = [0, 1] &#125; else &#123; this.distributionWordsArray[element][1] += 1 &#125; &#125; &#125;)&#125; 第四步，根据词频向量计算相似程度12句子A： &quot;太阳刚升起夕阳已落下&quot;句子B： &quot;我在马路边夕阳已落下&quot; 通过计算，我们会得到这样一个词频数组 结合余弦定理: 对于n维向量的计算如下: 而计算出来的余弦值越接近1，则表明夹角越接近0度，也就是两个向量越相似。 参见/index.js#71 123456789101112131415/** * 处理相似度 * @returns &#123;Number&#125; */similarity() &#123; let [sum, sumWordsA, sumWordsB] = [0, 0, 0] for (const element in this.distributionWordsArray) &#123; const wordsA = this.distributionWordsArray[element][0] const wordsB = this.distributionWordsArray[element][1] sum += (wordsA * wordsB) sumWordsA += Math.pow(wordsA, 2) sumWordsB += Math.pow(wordsB, 2) &#125; return sum / Math.sqrt(sumWordsA * sumWordsB)&#125; 找对象和做文章自动分类一样 第一步，基本信息、个性、兴趣爱好分析和分词原理类似，我们要将每个人的物理数据数字化，并按照不同的维度拆分 第二步，列出所有数字化后的数据分析之后，我们将得到数字化的人物画像。 第三步，参数统计对数字化后的每一项数据，进行统计 第四步，计算相似程度这里用到的计算方法和词频统计一样，而拓展一些的地方是，可以给某些参数增加权重。 这样就可以结合你的个人状况，找到最适合你的对象了。 大数据你应该已经注意到了，我们做文章自动分类的前提，是有足够多的文章数据 所以，用余弦定理+大数据找到心仪的对象，也需要有足够多的数字化数据。 而一切的前提，是要有足够多的对象数据，所以要先挖掘下数据吧。 Plan我有个帮你找对象的计划，如果你有找对象的需求，可以提交到我的系统里面来哦～ 项目地址文中代码仓库请访问 https://github.com/tkvern/nodejs-text-similarity","categories":[],"tags":[],"keywords":[]},{"title":"梦回长安","slug":"梦回长安","date":"2020-03-15T23:35:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20200315/梦回长安/","link":"","permalink":"https://tkvern.com/20200315/梦回长安/","excerpt":"昨日酒醉，赋诗一首，作此诗于深圳，2020-03-16 07:35 笔","text":"昨日酒醉，赋诗一首，作此诗于深圳，2020-03-16 07:35 笔 梦回长安张翔霓裳羽衣相思久梦回长安城里住极乐宴上睹芳容醉入酒池方醒悟","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"旧人","slug":"旧人","date":"2019-11-19T00:16:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20191119/旧人/","link":"","permalink":"https://tkvern.com/20191119/旧人/","excerpt":"忆旧人，有感，作此诗于深圳，2019-11-19 08:16 笔","text":"忆旧人，有感，作此诗于深圳，2019-11-19 08:16 笔 旧人张翔提墨入江湖染半分俗事佳人不舍情到深时待笔停 已泪满长裳或入梦里旧人模样故地笑语似醒似梦至天明 湿红枕","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"面朝大海，春暖花开","slug":"面朝大海春暖花开","date":"2019-06-14T16:31:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20190614/面朝大海春暖花开/","link":"","permalink":"https://tkvern.com/20190614/面朝大海春暖花开/","excerpt":"像海子一样，面朝大海，春暖花开，作此诗于深圳，2019-06-15 00:31 笔","text":"像海子一样，面朝大海，春暖花开，作此诗于深圳，2019-06-15 00:31 笔 从明天起做一个幸福的人减肥 阅读 正经一点从明天起多食牛奶和蔬菜再买一所房子面朝大海 春暖花开","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"论假百度钓鱼网站的实现过程","slug":"论假百度钓鱼网站的实现过程","date":"2017-02-28T03:23:55.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20170228/论假百度钓鱼网站的实现过程/","link":"","permalink":"https://tkvern.com/20170228/论假百度钓鱼网站的实现过程/","excerpt":"近日在UC头条上看到一则新闻【 网友反映可能上了“假百度” 官方通报: 百度搜索移动端被劫持 】 今天来讨论一些假百度的实现过程，防止大家以后上当受骗。未看新闻的童鞋先去补补课。下面是概览图。","text":"近日在UC头条上看到一则新闻【 网友反映可能上了“假百度” 官方通报: 百度搜索移动端被劫持 】 今天来讨论一些假百度的实现过程，防止大家以后上当受骗。未看新闻的童鞋先去补补课。下面是概览图。 仿制百度移动版网站会Web开发的童鞋都知道，仿制网站的第一步就是将站点的资源都抠下来。如下 不需要的JS可以删除掉，页面上的链接可以任意发挥。 修改DNS解析，让假百度更真给域名添加一个baidu.com的前缀，以假乱真。 购买免费子域名证书，疏而不漏在手机上访问时会有个安全的小钥匙，这个必不可少 买了免费证书配置到Nginx代理中就可使用了。 重点，劫持用户只需要简单的JS就可以劫持用户的真实地址了，当用户通过百度搜索进入的你的网站时，你就可以劫持用户到假百度去了。至于怎么让百度能搜索到你的网站，这就可以问问百度了，百度有竞价排名。 12345678window.onload=function()&#123; //用于捕获浏览器回退事件，或手机回退的物理按键 history.pushState(null,null,null); window.onpopstate=function()&#123; //当用户点击后退时，进入假百度 location.replace(\"https://baidu.com-search.xxx.com\"); &#125;&#125;; 结语本文旨在防止大家上当受骗，解析钓鱼网站是如何使用的，切勿非法使用！！！","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://tkvern.com/categories/网络安全/"}],"tags":[{"name":"钓鱼网站","slug":"钓鱼网站","permalink":"https://tkvern.com/tags/钓鱼网站/"}],"keywords":[{"name":"网络安全","slug":"网络安全","permalink":"https://tkvern.com/categories/网络安全/"}]},{"title":"Dva + Ant Design 前后端分离之 React 应用实践","slug":"Dva + Ant Design 前后端分离之 React 应用实践","date":"2017-02-04T09:31:07.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20170204/Dva + Ant Design 前后端分离之 React 应用实践/","link":"","permalink":"https://tkvern.com/20170204/Dva + Ant Design 前后端分离之 React 应用实践/","excerpt":"继 Rails 从入门到完全放弃 拥抱 Elixir + Phoenix + React + Redux 这篇文章被喷之后，笔者很长一段时候没有上社区逛了。现在 tkvern 又回归了，给大家带来React实践的一些经验，一些踩坑的经验。 Rails嘛，很好用，Laravel也好用。Phoenix也好用。都好，哪个方便用哪个。 还有关于Turbolinks之争，不能单从页面渲染时间去对比，要综合考虑。","text":"继 Rails 从入门到完全放弃 拥抱 Elixir + Phoenix + React + Redux 这篇文章被喷之后，笔者很长一段时候没有上社区逛了。现在 tkvern 又回归了，给大家带来React实践的一些经验，一些踩坑的经验。 Rails嘛，很好用，Laravel也好用。Phoenix也好用。都好，哪个方便用哪个。 还有关于Turbolinks之争，不能单从页面渲染时间去对比，要综合考虑。 Why Dva？Dva是基于Redux做了一层封装，对于React的state管理，有很多方案，我选择了轻量、简单的Dva。至于Mobx，还没应用到项目中来。先等友军踩踩坑，再往里面跳。 Why dva and what’s dva 支付宝前端应用架构的发展和选择 顺便贴下Dva的特性： 易学易用：仅有 5 个 api，对 redux 用户尤其友好 elm 概念：通过 reducers, effects 和 subscriptions 组织 model 支持 mobile 和 react-native：跨平台 (react-native 例子) 支持 HMR：目前基于 babel-plugin-dva-hmr 支持 components 和 routes 的 HMR 动态加载 Model 和路由：按需加载加快访问速度 (例子) 插件机制：比如 dva-loading 可以自动处理 loading 状态，不用一遍遍地写 showLoading 和 hideLoading 完善的语法分析库 dva-ast：dva-cli 基于此实现了智能创建 model, router 等 支持 TypeScript：通过 d.ts (例子) Why Ant Design?做为传道士，这么好的UI设计语言，肯定不会藏着掖着啦。蚂蚁金服的东西，确实不错，除了Ant Design外，还有Ant Design Mobile、AntV、AntMotion、G2。 Why yarn?npm install 太慢，试试yarn吧。建议用npm install yarn -g进行安装。 开发过程中的前后端分离项目开始了，前端视图写完，要开始数据交互了，后端提供的API还没好。 那么问题来了，如何在不依靠后端提供API的情况下，实现数据交互？ 使用Mock.js可以解决这个问题。先对接好API数据格式，然后使用Mockjs拦截Ajax请求，模拟后端真实数据。 在Mockjs官方提供的API不够用的情况下，还可以使用正则产生模拟数据。 如何对模拟做数据持久化处理？这里给出一个模拟用户数据并持久化的实例实例：mock/users.js 代码摘要: 12345678910111213141516171819202122232425262728293031323334353637383940414243'use strict';const qs = require('qs');const mockjs = require('mockjs');const Random = mockjs.Random;// 数据持久化let tableListData = &#123;&#125;;if (!global.tableListData) &#123; const data = mockjs.mock(&#123; 'data|100': [&#123; 'id|+1': 1, 'name': () =&gt; &#123; return Random.cname(); &#125;, 'mobile': /1(3[0-9]|4[57]|5[0-35-9]|7[01678]|8[0-9])\\d&#123;8&#125;/, 'avatar': () =&gt; &#123; return Random.image('125x125'); &#125;, 'status|1-2': 1, 'email': () =&gt; &#123; return Random.email('visiondk.com'); &#125;, 'isadmin|0-1': 1, 'created_at': () =&gt; &#123; return Random.datetime('yyyy-MM-dd HH:mm:ss'); &#125;, 'updated_at': () =&gt; &#123; return Random.datetime('yyyy-MM-dd HH:mm:ss'); &#125;, &#125;], page: &#123; total: 100, current: 1, &#125;, &#125;); tableListData = data; global.tableListData = tableListData;&#125; else &#123; tableListData = global.tableListData;&#125; 模拟API怎么写？完成持久化处理后，就可以像操作数据库一样进行增、删、改、查 下面是一个删除用户的API 参见mock/users.js#L106： 1234567891011121314151617181920212223'DELETE /api/users' (req, res) &#123; setTimeout(() =&gt; &#123; const deleteItem = qs.parse(req.body); tableListData.data = tableListData.data.filter((item) =&gt; &#123; if (item.id === deleteItem.id) &#123; return false; &#125; return true; &#125;); tableListData.page.total = tableListData.data.length; global.tableListData = tableListData; res.json(&#123; success: true, data: tableListData.data, page: tableListData.page, &#125;); &#125;, 200); &#125;, 还有一步模拟数据和API写好了，还需要拦截Ajax请求 修改package.json 1234567891011...\"scripts\": &#123; \"start\": \"dora --plugins \\\"proxy,webpack,webpack-hmr\\\"\", \"build\": \"atool-build -o ../../../public\", \"test\": \"atool-test-mocha ./src/**/*-test.js\"&#125;... 如果与dora有端口冲突可修改dora的端口号 1\"start\": \"dora --port 8888 --plugins \\\"proxy,webpack,webpack-hmr\\\"\", 完成这些基本工作就做好了 友情提示在模拟数据环境，services下的模块这么写就好了，真实API则替换为真实API的地址。可将地址前缀写到统一配置中去。 1234567891011121314151617181920212223242526import request from '../utils/request';import qs from 'qs';export async function query(params) &#123; return request(`/api/users?$&#123;qs.stringify(params)&#125;`);&#125;export async function create(params) &#123; return request('/api/users', &#123; method: 'post', body: qs.stringify(params), &#125;);&#125;export async function remove(params) &#123; return request('/api/users', &#123; method: 'delete', body: qs.stringify(params), &#125;);&#125;export async function update(params) &#123; return request('/api/users', &#123; method: 'put', body: qs.stringify(params), &#125;);&#125; 真实API参考实例: src/services/users.js 如何保持登录状态在看dva的引导手册时，并没有介绍登录相关的内容。因为不同的项目，对于登录这块的实现会有所不同，并不是唯一的。通常我们会使用Cookie的方式保持登录状态，或者 Auth 2.0的技术。 这里介绍Cookie的方式。 登录成功之后服务器会设置一个当前域可以使用的Cookie，例如token啥的。然后在每次数据请求的时候在Request Headers中携带token，后端会基于这个token进行权限验证。思路清晰了，来看看具体实现吧。（注：在这次项目中使用了统一登录模块，通过Header中的Authorization进行验证，将只介绍拿到token之后的数据处理） 准备工作对于操作Cookie的一些操作，建议先封装到工具类模块下。同时我把操作LocalStrage的一些操作也写进来了。 参见src/utils/helper.js 123456789101112131415161718192021222324...// Operation Cookieexport function getCookie(name) &#123; const reg = new RegExp('(^| )' + name + '=([^;]*)(;|$)'); const arr = document.cookie.match(reg); if (arr) &#123; return decodeURIComponent(arr[2]); &#125; else &#123; return null; &#125;&#125;export function delCookie(&#123; name, domain, path &#125;) &#123; if (getCookie(name)) &#123; document.cookie = name + '=; expires=Thu, 01-Jan-70 00:00:01 GMT; path=' + path + '; domain=' + domain; &#125;&#125;... Header的预处理我放在了src/utils/auth.js#L5，这里后端返回的数据都是JSON格式，所以在Header里面需要添加application/json进去，而Authorization是后端用来验证用户信息的。变量sso_token为了方便代码阅读就没有按照规范命名了。 123456789export function getAuthHeader(sso_token) &#123; return (&#123; headers: &#123; 'Accept': 'application/json', 'Authorization': 'Bearer ' + sso_token, 'Content-Type': 'application/json', &#125;, &#125;);&#125; 修改Request这里没有使用自带的catch机制来处理请求错误，在开发过程中，最开始打算使用统一错误处理，但是发现请求失败后，不能在models层处理components，所以就换了一种方式处理，后面会讲到。 参见src/utils/request.js#L29 123456789export default function request(url, options) &#123; const sso_token = getCookie('sso_token'); const authHeader = getAuthHeader(sso_token); return fetch(url, &#123; ...options, ...authHeader &#125;) .then(checkStatus) .then(parseJSON) .then((data) =&gt; (&#123; data &#125;)); // .catch((err) =&gt; (&#123; err &#125;));&#125; 完成这些配置之后，每次向服务器发送的请求就都携带了用户token了。在token无效时，服务器会抛出401错误，这时就需要在中间件中处理401错误。 参见src/utils/request.js#L10 redirectLogin是工具类src/utils/auth.js中的重定向登录方法。 1234567891011function checkStatus(response) &#123; if (response &amp;&amp; response.status === 401) &#123; redirectLogin(); &#125; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 500) &#123; return response; &#125; const error = new Error(response.statusText); error.response = response; throw error;&#125; 到此为止，登录状态的配置基本完成。 Router我们的应用中会有多个页面，而且有的需要登录才可见，那么如何控制呢？ React的路由控制是比较灵活的，来看看下面这个例子： src/router.jsx 12345678910111213141516171819202122import React from 'react';import &#123; Router, Route &#125; from 'dva/router';import &#123; authenticated &#125; from './utils/auth';import Dashboard from './routes/Dashboard';import Users from './routes/Users';import User from './routes/User';import Password from './routes/Password';import Roles from './routes/Roles';import Permissions from './routes/Permissions';export default function (&#123; history &#125;) &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path=\"/\" component=&#123;Dashboard&#125; onEnter=&#123;authenticated&#125; /&gt; &lt;Route path=\"/user\" component=&#123;User&#125; onEnter=&#123;authenticated&#125; /&gt; &lt;Route path=\"/password\" component=&#123;Password&#125; onEnter=&#123;authenticated&#125; /&gt; &lt;Route path=\"/users\" component=&#123;Users&#125; onEnter=&#123;authenticated&#125; /&gt; &lt;Route path=\"/roles\" component=&#123;Roles&#125; onEnter=&#123;authenticated&#125; /&gt; &lt;Route path=\"/permissions\" component=&#123;Permissions&#125; onEnter=&#123;authenticated&#125; /&gt; &lt;/Router&gt; );&#125; 对于路由的验证配置在onEnter属性中，authenticated方法可统一进行路由验证，要注意每一个Route节点的验证都需要配置相应的onEnter属性。如果权限较为复杂需对每一个Route单独验证。其实这种基于客户端渲染的应用，如果页面限制有遗漏也关系不太，后端提供的API会对数据进行验证，即使前端访问到没有权限的页面，也同样不用担心，做好客户端错误处理即可。 数据缓存对于一个React应用来说，缓存是很重要的一步。前后端分离后，频繁的Ajax请求会消耗大量的服务器资源，如果一些不长变动的持久化数据不做缓存的话，会浪费许多资源。所以，比较常见的方法就是将数据缓存在LocalStorage中。针对一些敏感信息可适当进行加密混淆处理，我这里就不介绍了。 什么时候做数据缓存?例：用户信息缓存 参见src/models/auth.js#L64 在subscriptions中配置了setup检测LocalStorage中的user是否存在。不存在时会去query用户信息，然后保存到user中，如果存在就将user中的数据添加到state的user: {}中。当然在进行请求时，已经在src/utils/auth.js验证用户信息是否正确，同时做了相应的限制src/utils/auth.js#L20 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import &#123; parse &#125; from 'qs';import &#123; message &#125; from 'antd';import &#123; query, update, password &#125; from '../services/auth';import &#123; getLocalStorage, setLocalStorage &#125; from '../utils/helper';export default &#123; namespace: 'auth', state: &#123; user: &#123;&#125;, isLogined: false, currentMenu: [], &#125;, reducers: &#123; querySuccess(state, action) &#123; return &#123; ...state, ...action.payload, isLogined: true &#125;; &#125;, &#125;, effects: &#123; *query(&#123; payload &#125;, &#123; call, put &#125;) &#123; const &#123; data &#125; = yield call(query, parse(payload)); if (data &amp;&amp; data.err_msg === 'SUCCESS') &#123; setLocalStorage('user', data.data); yield put(&#123; type: 'querySuccess', payload: &#123; user: data.data, &#125;, &#125;); &#125; &#125;, &#125; subscriptions: &#123; setup(&#123; dispatch &#125;) &#123; const data = getLocalStorage('user'); if (!data) &#123; dispatch(&#123; type: 'query', payload: &#123;&#125;, &#125;); &#125; else &#123; dispatch(&#123; type: 'querySuccess', payload: &#123; user: data, &#125;, &#125;); &#125; &#125;, &#125;,&#125; 简单来说，就是没有缓存的时候缓存。 什么时候更新数据缓存？例如，roles中添加和修改功能都需要用到permissions的数据，哪我怎么拿到最新的permissions数据呢。首先，我在加载roles列表页面时就需要将permissions的数据缓存，这样，在每次点添加或修改功能时就不需要再去拉取已缓存的数据了。 参见src/models/roles.js#L166 在监听路由到roles时查询permissions是否缓存，将其更新到缓存中去。 12345678910111213141516171819202122232425... subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; history.listen((location) =&gt; &#123; const match = pathToRegexp('/roles').exec(location.pathname); if (match) &#123; const data = getLocalStorage('permissions'); if (!data) &#123; dispatch(&#123; type: 'permissions/updateCache', &#125;); &#125; dispatch(&#123; type: 'query', payload: location.query, &#125;); &#125; &#125;); &#125;, &#125;,... 什么时候删除数据缓存？删除缓存的配置是比较灵活的，这里的业务场景并不复杂所以，我用了比较简单的处理方式。 参见src/models/permissions.js#L112 在执行新增或更新操作成功后，将本地原有的缓存删除。加上数据联动的特性，当再次回到roles操作时，缓存已经更新了。 123456789101112131415161718192021... *update(&#123; payload &#125;, &#123; select, call, put &#125;) &#123; yield put(&#123; type: 'hideModal' &#125;); yield put(&#123; type: 'showLoading' &#125;); const id = yield select((&#123; permissions &#125;) =&gt; permissions.currentItem.id); const newRole = &#123; ...payload, id &#125;; const &#123; data &#125; = yield call(update, newRole); if (data &amp;&amp; data.err_msg === 'SUCCESS') &#123; yield put(&#123; type: 'updateSuccess', payload: newRole, &#125;); localStorage.removeItem('permissions'); message.success('更新成功!'); &#125; &#125;,... State的临时缓存state的中的数据是变化的，刷新页面之后会重置掉，也可以将部分models中的state存到Localstorage中，让state的数据从Localstorage读取，但不是必要的。而list数据的更新，是直接操作state中的数据的。 如下(这样就不用更新整个list的数据了)。 1234567891011121314151617... grantSuccess(state, action) &#123; const grantUser = action.payload; const newList = state.list.map((user) =&gt; &#123; if (user.id === grantUser.id) &#123; user.roles = grantUser.roles; return &#123; ...user &#125;; &#125; return user; &#125;); return &#123; ...state, ...newList, loading: false &#125;; &#125;,... 视图组件运用Ant 提供的组件非常多，但用起来还是需要一些学习成本的，同时多个组件组合使用时也需要有很多地方注意的。 Modal注意事项在使用Modal组件时，难免会出现一个页面多个Modal的情况，首先要注意的就是Modal的命名，在多Modal情况下，命名不注意很容易出现分不清用的是哪个Modal。建议命名时能望名知意。然后就是Modal需要用到别的Models的数据时，如果在弹窗时通过Ajax获取需要的数据再显示Modal，这样就会出现Modal延迟，而且Modal的动画也无法加载出来。所以，我的处理方式是，在进入这一级Route的时候就将需要的数据预缓存，这样调用时就可随用随取，不会出现延迟了。 参见src/components/user/UserModalGrant.jsx#L33 Form注意Ant的form组件很完善，需要注意的就是表单的多条件查询。如果单单是一个条件查询的处理比较简单，将查询关键词设成string类型存到相应的Models中的state即可，多条件的话，稍微麻烦一点，需存成Hash对象。灵活处理即可。 其他官方文档的描述很清楚，我就不充大头了。注意写法规范即可，直接复制粘贴官方例子代码会很难看。 跨域问题终于说到点子上了，前后端分离遇到跨域问题很正常，而这种基于RESTful API的前后端分离就更好弄了。我这以Fetch + PHP + Laravel为例，这种并不是最有解决方案！仅供参考！ 在header中进行如下配置 Access-Control-Allow-Origin配置允许的域 Access-Control-Allow-Methods配置允许的请求方式 Access-Control-Allow-Headers配置允许的请求头 123456789101112131415161718192021&lt;?phpuse Illuminate\\Http\\Request;/*|--------------------------------------------------------------------------| API Routes|--------------------------------------------------------------------------|| Here is where you can register API routes for your application. These| routes are loaded by the RouteServiceProvider within a group which| is assigned the \"api\" middleware group. Enjoy building your API!|*/Route::group(['middleware'=&gt; ['auth:api']], function() &#123; header(\"Access-Control-Allow-Origin: *\"); header(\"Access-Control-Allow-Methods: GET, HEAD, POST, PUT, PATCH, DELETE\"); header(\"Access-Control-Allow-Headers: Access-Control-Allow-Headers, Origin, Accept, Authorization, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers\"); require base_path('routes/common.php');&#125;); 基于其他编程语言的处理类似。 结语了解前端、熟悉前端、精通前端、熟悉前端、不懂前端 了解 X X 、熟悉 X X 、精通 X X 、熟悉 X X 、不懂 X X","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}],"tags":[{"name":"React","slug":"React","permalink":"https://tkvern.com/tags/React/"}],"keywords":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}]},{"title":"回家","slug":"回家","date":"2017-01-13T01:32:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20170113/回家/","link":"","permalink":"https://tkvern.com/20170113/回家/","excerpt":"打油诗，改自网络版本，作此诗于深圳，2017-01-13 09:32 笔","text":"打油诗，改自网络版本，作此诗于深圳，2017-01-13 09:32 笔 回家瘦小离家胖时归乡音未改肉成堆儿童相见不相识笑问胖从何处来","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"Rails 从入门到完全放弃","slug":"Rails从入门到完全放弃","date":"2016-07-21T15:36:47.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160721/Rails从入门到完全放弃/","link":"","permalink":"https://tkvern.com/20160721/Rails从入门到完全放弃/","excerpt":"前言这是一篇关于Rails的开发经历的文章，旨在将Rails中遇到的各种问题分享给还未接触Rails或是已经上路的朋友。虽说做Rails的开发时间不长，刚好一年多。但是，在这一年的时间中，该使用的技术架构，Ruby-China 推荐的Gem包，都尝试过使用过了，也为业务开发了一些Gem包。谈不上精通Rails，如果把Rails作者定为最高等级，他是F1赛车手，我该是个跑出租的老司机。","text":"前言这是一篇关于Rails的开发经历的文章，旨在将Rails中遇到的各种问题分享给还未接触Rails或是已经上路的朋友。虽说做Rails的开发时间不长，刚好一年多。但是，在这一年的时间中，该使用的技术架构，Ruby-China 推荐的Gem包，都尝试过使用过了，也为业务开发了一些Gem包。谈不上精通Rails，如果把Rails作者定为最高等级，他是F1赛车手，我该是个跑出租的老司机。 背景早前有做过Java，PHP，.Net的开发，相信玩Rails的朋友多多少少也都有写过，不过主要还是以前端为主。早在IE7/IE8 时代做前端开发，那时Node.js还没火起来，前端成了低技术含量又耗体力又没地位的活。不过，还好有Node.js，让我赶上了这个时代。 怎么接触到Rails当公司的一个PHP的多人即时聊天项目接近尾声时，我们在思考能不能将程序员生产力解放出来？是不是可以尝试一些其他的技术架构。很快，经过多方研究，发现Rails是单兵作战的神器。相比PHP，可以达到Rails : PHP = 1 : 4 的效率。但对于一个技术架构成熟的技术团队来说，放弃原有的技术架构去使用一个从未接触过新技术，时间成本和决心是很重要的。但挑战往往会带来意想不到的收获。 在深大图书馆的 Rails之道学习新技术的第一件事就是去找学习资料。在google上找了很久，发现深大图书馆有各种各样的技术书籍，果不其然，在这里找到了Ruby元编程，Rails之道，敏捷开发之道这些书籍，但是版本比较老。为了能够掌握最新版本的知识，下载了相应的英文版PDF，一起结合。修炼Rails的过程是痛并快乐着的，因为要转变思维模式，去接受新的思想，去了解诸多的语法糖因何而生。学累了就躺会，饿了就上个外卖，脑袋成浆糊了就洗把脸。其实接触一门新语言并不是多难，这是一个循序渐进的过程。好在前端底子厚，学习ERB，UJS，RJS的过程比较轻松，但是Turbolinks对于前端工程师来说就是噩梦，一直到现在我都用的Pjax。不喜欢Turbolinks的做法，Pjax显得很机智。关于Turbolinks和Pjax我并不是挑起战争，仁者见仁，智者见智。 用Rails对电商的探索在构建电商系统的时候，很自然就 pull 了ECShop的源码来学习。业务上的问题并不大，有现成案例，结合需求来订制开发很快。同时在开发过程中Ruby-China社区也提供了许多帮助。类似查询 N + 1问题，CanCanCan权限问题….. 文件上传上传图片对于图片等资源的处理，最开始没有选用Carrierwave的方案，而是使用七牛云存储JS SDK，开始接触的时候，发现并没有多少参考文档，于是想是不是这个东西比较简单也比较少人用，还是Ruby-China 社区的朋友太懒。后面深入研究后发现，这类云存储的方法还是用得比较多，也比较便捷，但对于新手还是有一定门槛，所以做完之后顺带写了相应的教程造福社会。 富文本编辑器上传图片在富文本编辑器中Froala可以说是佼佼者，我们选用了Froala。但是遇到一个问题，Froala中的图片上传仅支持Amazon云，因此不得不改造Froala的源码。幸运的是这个过程并不困难，我将改造后的Froala用策略模式做成了一个Gem: wysiwyg-rails-qiniu，又一次造福社会。 猴子补丁在使用will_paginate的时候，分页的结构与样式与Materia UI的风格并不相符，并且没有找到合适的Gem，所以大胆的用起了打开类的法术，并且纪录了这一过程《 为什么重写will_paginate 》 Pjax使用Pjax的过程相对比较顺利，在听完Rei大神对Turbolinks的讲解之后，还是坚定不移的使用Pjax，值得注意的是在使用WiceGrid的时候，会存在初始化组件问题，当时是使用data-skip-pjax解决。不过现在前后端分离，前端使用React ＋ Redux操作DOM比以往轻松多了。事实上WiceGrid的筛选方式对于用户并不友好。 Devise 和 OmniAuth这两个Gem的使用不多，在尝试过Devise之后，还是得自己手写一遍登录等功能，第三方登录开始有考虑用，后面发现还用不上就没有研究了。 china_city在使用china_city的时候发现一个小问题。123456789101112(($) -&gt; $.fn.china_city = () -&gt; @each -&gt; // 下面这一行选择.city-select的时候没有限制为select // 如果class有冲突会出现bug. // 所以更正为 $(@).find('select.city-select') selects = $(@).find('.city-select') selects.change -&gt; . . .)(jQuery) 前端css框架在开发中多次切换了前端技术栈。只想告诉大家，Materia UI并不适合后台使用，而且与诸多的Gem包存在兼容问题，Rails中大部分跟前端有关的Gem都是基于Bootstrap。所以觉得Bootstrap审美疲劳的朋友，还是继续用着吧。 前端JS处理随着JS的增多，维护起来会越来越难，在Rails的项目中并没有做JS模块化，而是将JS用工厂模式汇集到了一起，新的功能代码会放到工厂车间去，在使用的时候 new 一个工厂，调用需要的功能即可，同时保证了可复用性。 部署其实Rails的应用部署相对比较容易，没有太多的内容。只要注意配置文件加后缀防止被新的commit覆盖就好了，一般来说，写好shell脚本实现一键部署也并非难事。 微信支付现今主流的是微信支付和支付宝支付，银联的太蛋疼了。相比与微信支付，支付宝的文档真心不友好，看到吐，而且申请流程繁琐。如果你有打算在项目中使用支付宝支付，最好提前两个月做申请。虽然我不太喜欢马化腾，但是微信支付的文档我给32个赞，使用起来也方便。微信支付的申请流程更加透明一些，每个节点都很快。使用下面的Gem12gem 'wechat'gem 'wx_pay' 但是也有一个问题待解决，就是在支付时取消订单，数据库状态更新，而微信支付的数据状态未更新，再进行支付的时候就会出现订单号已存在的error。 微信支付虚拟键盘在便利店用过微信支付的朋友应该知道， 好近这样的第三方支付商的虚拟键盘。开始做虚拟键盘的时候想扒一下好近的源码，奈何用微信开发调试工具根本拿不到。所以只能自己写，遇到的第一个问题就是点击事件延迟300ms，虽说可用Tap事件，被搞得不要不要的。先后尝试了JqueryMobile.Tap，FastClick等解决方法，仍然是在Android上延迟超高，IOS流畅。后面灵感闪现，我为什么要给用户一个完整的点击事件呢？一碰到就触发键盘不是可以让用户得到的反馈跟好么。索性偷懒了一把。1$(element).on('touchstart', function(e)&#123;/* do something */&#125; Rails 的问题Rails从诞生到现在，已有经年。开发过程中最拖慢开发进度的不是需求变动，也不是技术点，使用了assets pipeline的话，在调试页面的时候资源加载总是很慢。实在受不了的时候尝试了结合Node.js，用Gulp browser sync，来代理资源，虽说速度快超多，但不是官方集成的方案，多多少少让强迫症的人很难受。对于业务复杂的电商系统来说，Rails标准的Action肯定不够用，而自定义的写出来感觉不伦不类，可能是功夫不到家，但是没有找到更好的编程参考。其他的就是性能问题了，了解Elixir的朋友应该就知道了。 跟着Peter学Meteor响应Peter的号召，我也全情的投入到了Meteor ＋ React ＋ Redux 的大军中去了。虽说没用Meteor做过大型项目，但是小应用做起来是得新应手了。好像也没有看到有多少大型项目用Meteor + React + Redux 技术栈的。用上React前端代码思路和结构变得清晰多了。也可以使用诸多的React组件了。类似于Amazeui，Ant Design，这些优秀的设计，连UI的费用都省了。 我与Elixir 和 Phoenix 不能说的秘密Elixir不用我说，相信大家都有耳闻了，函数式编程是未来。一个专业前端的Rails工程师切换到Elixir的过程没有第一次经历的痛苦，当你接受了函数式的思想之后相当顺畅。社区里面有的人说Phoenix抄Rails的，我并不认同，Phoenix传承了敏捷开发的思想，也为开发者提供了诸多的便利，像Hot load的技术也被集成进来，对于Socket的支持也是相当的好。融合Elixir的特性，让多线程成为利器，利好多多，如果可以，你应该像我一样去深入研究下Phoenix，还有你们常用的Devise也是Phoenix的作者写的。当Rails老了，你还有Phoenix 结束语AD：你错过了房地产，错过了网购，错过了炒股，别再错过Elixir Phoenix React Redux。作者：本猿不才，文采平平，且读切珍惜。","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://tkvern.com/categories/Ruby-on-Rails/"}],"tags":[{"name":"Rails","slug":"Rails","permalink":"https://tkvern.com/tags/Rails/"}],"keywords":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://tkvern.com/categories/Ruby-on-Rails/"}]},{"title":"FlowRouter 中文文档","slug":"FlowRouter-中文文档","date":"2016-06-12T07:24:15.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160612/FlowRouter-中文文档/","link":"","permalink":"https://tkvern.com/20160612/FlowRouter-中文文档/","excerpt":"TKVERN 翻译 | 源文档链接FlowRouter (如果你发现翻译中存在谬误的地方, 请留言, 我会继续造福社会. 建议结合源文档查看翻译) 为Meteor精心设计的客户端Router FlowRouter 是 Meteor 一个非常简单的路由器.它为客户端程序routing,不处理渲染本身. 它为改变URL和获取数据获取提供了一个良好的API. 然而, 在router内部, 这不是reactive. 最重要的是, FlowRouter 的设计时考虑到性能和专注于自己最擅长的: routing. 如果你已经在使用 FlowRouter,我们发布了2.0版本,同时遵循 migration guide.","text":"TKVERN 翻译 | 源文档链接FlowRouter (如果你发现翻译中存在谬误的地方, 请留言, 我会继续造福社会. 建议结合源文档查看翻译) 为Meteor精心设计的客户端Router FlowRouter 是 Meteor 一个非常简单的路由器.它为客户端程序routing,不处理渲染本身. 它为改变URL和获取数据获取提供了一个良好的API. 然而, 在router内部, 这不是reactive. 最重要的是, FlowRouter 的设计时考虑到性能和专注于自己最擅长的: routing. 如果你已经在使用 FlowRouter,我们发布了2.0版本,同时遵循 migration guide. TOC Meteor Routing Guide Getting Started Routes Definition Group Routes Rendering and Layout Management Triggers Not Found Routes API Subscription Management IE9 Support Hashbang URLs Prefixed paths Add-ons Difference with Iron Router Migrating into 2.0 Meteor Routing GuideMeteor Routing Guide 是一个关于 Meteor routing 主题的完整指南 . 谈论了如何正确使用 FlowRouter 和 Blaze and React. 也显示了如何管理 subscriptions 和在视图实现 auth logic. Getting Started添加 FlowRouter 到你的app: 1meteor add kadira:flow-router 让我们写第一个 route (添加文件到 lib/router.js): 12345FlowRouter.route('/blog/:postId', &#123; action: function(params, queryParams) &#123; console.log(\"Yeah! We are on the post:\", params.postId); &#125;&#125;); 在浏览器访问 /blog/my-post-id, 或从console调用下面的命令: 1FlowRouter.go('/blog/my-post-id'); 然后,你就可以在console看到打印的消息了. Routes DefinitionFlowRouter 的 routes 非常简单, Express 和 iron:router都有使用基于path-to-regexp的语法 下面是一个简单的route语法: 123456789FlowRouter.route('/blog/:postId', &#123; // do some action for this route action: function(params, queryParams) &#123; console.log(\"Params:\", params); console.log(\"Query Params:\", queryParams); &#125;, name: \"&lt;name for the route&gt;\" // optional&#125;); 那么,当你访问这个url的时候,这条route就会被激活: 1FlowRouter.go('/blog/my-post?comments=on&amp;color=dark'); 在你访问这条route之后, console会打印下面内容: 12Params: &#123;postId: &quot;my-post&quot;&#125;Query Params: &#123;comments: &quot;on&quot;, color: &quot;dark&quot;&#125; 对于单个 interaction, router只会运行一次. 这意味着, 在你访问 route 后, 它会首先调用 triggers, 接着是 subscriptions, 最后调用 action. 出现没有这些方法这种情况后,route访问将会再次调用. 你可以在 client 任何目录定义routes. 但是, 我们推荐你添加到 lib 目录. 那么 fast-render 能够检测 subscriptions 和 send 它们给你 (我们会在这里谈论). Group Routes你可以对routes分组来更好的组织route. 这是一个例子: 123456789101112131415161718192021222324var adminRoutes = FlowRouter.group(&#123; prefix: '/admin', name: 'admin', triggersEnter: [function(context, redirect) &#123; console.log('running group triggers'); &#125;]&#125;);// handling /admin routeadminRoutes.route('/', &#123; action: function() &#123; BlazeLayout.render('componentLayout', &#123;content: 'admin'&#125;); &#125;, triggersEnter: [function(context, redirect) &#123; console.log('running /admin trigger'); &#125;]&#125;);// handling /admin/postsadminRoutes.route('/posts', &#123; action: function() &#123; BlazeLayout.render('componentLayout', &#123;content: 'posts'&#125;); &#125;&#125;); 所有对于 FlowRouter.group() 的options都是可选的. 你甚至可以像下面一样嵌套group routes: 12345678910111213141516var adminRoutes = FlowRouter.group(&#123; prefix: \"/admin\", name: \"admin\"&#125;);var superAdminRoutes = adminRoutes.group(&#123; prefix: \"/super\", name: \"superadmin\"&#125;);// handling /admin/super/postsuperAdminRoutes.route('/post', &#123; action: function() &#123; &#125;&#125;); 你可以判断当前的route是在使用哪个group: 1FlowRouter.current().route.group.name 如果当前的route是具体的group (e.g. admin, public, loggedIn) 无需使用前缀,如果你不想.如果它是一个嵌套的group, 你可以像这样获取父级group的name: 1FlowRouter.current().route.group.parent.name 如同所有的当前 route 属性, 都不是 reactive, 但是可以结合FlowRouter.watchPathChange() 获取group名. Rendering and Layout ManagementFlowRouter 不处理渲染和布局管理. 为此, 你可以使用: Blaze Layout for Blaze React Layout for React 这样在一个route你可以从 action 的内部 method调用布局管理. 12345FlowRouter.route('/blog/:postId', &#123; action: function(params) &#123; BlazeLayout.render(\"mainLayout\", &#123;area: \"blog\"&#125;); &#125;&#125;); TriggersTriggers 是 FlowRouter 可以允许你在 enter 这个 route 之前和 exit 这个 route 之后执行相应的任务. Defining triggers for a route这里是如何为一个 route 定义 triggers : 12345678910111213141516171819FlowRouter.route('/home', &#123; // calls just before the action triggersEnter: [trackRouteEntry], action: function() &#123; // do something you like &#125;, // calls when when we decide to move to another route // but calls before the next route started triggersExit: [trackRouteClose]&#125;);function trackRouteEntry(context) &#123; // context is the output of `FlowRouter.current()` Mixpanel.track(\"visit-to-home\", context.queryParams);&#125;function trackRouteClose(context) &#123; Mixpanel.track(\"move-from-home\", context.queryParams);&#125; Defining triggers for a group route这里是如何在一个 group 定义里定义 triggers. 12345var adminRoutes = FlowRouter.group(&#123; prefix: '/admin', triggersEnter: [trackRouteEntry], triggersExit: [trackRouteEntry]&#125;); 你可以添加 triggers 到单个 routes 或是 group . Defining Triggers Globally你同样可以定义全局 triggers. 这里是怎么做: 123456FlowRouter.triggers.enter([cb1, cb2]);FlowRouter.triggers.exit([cb1, cb2]);// filteringFlowRouter.triggers.enter([trackRouteEntry], &#123;only: [\"home\"]&#125;);FlowRouter.triggers.exit([trackRouteExit], &#123;except: [\"home\"]&#125;); 如你所看到的最后两个例子, 你可以筛选 routes 使用 only 或者 except 关键字. 但是, 你不能同时使用 only and except. 如果你想了解更多关于 triggers 和 设计决策, 访问 here. Redirecting With Triggers你可以使用 triggers 重定向到一个不同 route . 你可以在triggers enter 和 exit 做到这一点. 看看如何做的吧: 12345678FlowRouter.route('/', &#123; triggersEnter: [function(context, redirect) &#123; redirect('/some-other-path'); &#125;], action: function(_params) &#123; throw new Error(\"this should not get called\"); &#125;&#125;); 每个 trigger callback 的第二个参数: 一个 function 你可以使用 redirect 到 一个不同的 route. Redirect 也有一些属性来确保不会阻止 router. redirect 必须是调用一个 URL redirect 必须在同一个event循环周期 (没有异步或调用内部 Tracker) redirect 不能多次调用 检查这个 PR 以了解更多关于 redirect 的 API. Stopping the Callback With Triggers在有些情况, 你也许需要停止使用 triggers 的 route callback. 你可以在 before triggers, 使用第三个参数: stop function. 例如, 你可以检查前缀, 如果失败, 在before action停止和显示 notFound layout. 12345678910111213141516171819var localeGroup = FlowRouter.group(&#123; prefix: '/:locale?', triggersEnter: [localeCheck]&#125;);localeGroup.route('/login', &#123; action: function (params, queryParams) &#123; BlazeLayout.render('componentLayout', &#123;content: 'login'&#125;); &#125;&#125;);function localeCheck(context, redirect, stop) &#123; var locale = context.params.locale; if (locale !== undefined &amp;&amp; locale !== 'fr') &#123; BlazeLayout.render('notFound'); stop(); &#125;&#125; Note: 当你使用 stop function,即使你不使用它,你应该通过第二个 redirect 参数. Not Found Routes你可以像这样配置 Not Found 的 routes: 123456789FlowRouter.notFound = &#123; // Subscriptions registered here don't have Fast Render support. subscriptions: function() &#123; &#125;, action: function() &#123; &#125;&#125;; APIFlowRouter 有丰富的 API 帮助你浏览这个 router 和获取这个 router 的信息. FlowRouter.getParam(paramName);你可以使用 Reactive function 获取 URL 的一个参数. 12345// route def: /apps/:appId// url: /apps/this-is-my-appvar appId = FlowRouter.getParam(\"appId\");console.log(appId); // prints \"this-is-my-app\" FlowRouter.getQueryParam(queryStringKey);你可以用Reactive function 的 queryString 查询你需要的value. 12345// route def: /apps/:appId// url: /apps/this-is-my-app?show=yes&amp;color=redvar color = FlowRouter.getQueryParam(\"color\");console.log(color); // prints \"red\" FlowRouter.path(pathDef, params, queryParams)从定义的path中生成path. 都有 params 和 queryParams 两个选项. URL的特殊字符在 params 和 queryParams 中会被转码. 123456var pathDef = \"/blog/:cat/:id\";var params = &#123;cat: \"met eor\", id: \"abc\"&#125;;var queryParams = &#123;show: \"y+e=s\", color: \"black\"&#125;;var path = FlowRouter.path(pathDef, params, queryParams);console.log(path); // prints \"/blog/met%20eor/abc?show=y%2Be%3Ds&amp;color=black\" 如果没有 params 或 queryParams, 这将只会返回 pathDef. Using Route name instead of the pathDef你也可以使用 route’s name 代替 pathDef. 那么, FlowRouter 会从给定的 route 选择 pathDef. 看下面的例子: 123456789101112FlowRouter.route(\"/blog/:cat/:id\", &#123; name: \"blogPostRoute\", action: function(params) &#123; //... &#125;&#125;)var params = &#123;cat: \"meteor\", id: \"abc\"&#125;;var queryParams = &#123;show: \"yes\", color: \"black\"&#125;;var path = FlowRouter.path(\"blogPostRoute\", params, queryParams);console.log(path); // prints \"/blog/meteor/abc?show=yes&amp;color=black\" FlowRouter.go(pathDef, params, queryParams);这将通过 FlowRouter.path 基于 arguments 和 re-route 到达相应的 path , . 你可以像这样调用 FlowRouter.go : 1FlowRouter.go(\"/blog\"); FlowRouter.url(pathDef, params, queryParams)就像 FlowRouter.path, 但给出的是绝对路径. (在后端使用 Meteor.absoluteUrl.) FlowRouter.setParams(newParams)这会改变当前的 params, re-route 到新的 path. 123456// route def: /apps/:appId// url: /apps/this-is-my-app?show=yes&amp;color=redFlowRouter.setParams(&#123;appId: \"new-id\"&#125;);// Then the user will be redirected to the following path// /apps/new-id?show=yes&amp;color=red FlowRouter.setQueryParams(newQueryParams)就像 FlowRouter.setParams, 但是是 queryString params. 删除 query param 设置为 null 如下: 1FlowRouter.setQueryParams(&#123;paramToRemove: null&#125;); FlowRouter.getRouteName()获取route reactively 的 name. 1234Tracker.autorun(function() &#123; var routeName = FlowRouter.getRouteName(); console.log(\"Current route name is: \", routeName);&#125;); FlowRouter.current()获取 router 的当前状态. This API is not reactive.如果你需要观察 path 的变化,可以使用 FlowRouter.watchPathChange(). 这给出来一个 object: 12345678910111213// route def: /apps/:appId// url: /apps/this-is-my-app?show=yes&amp;color=redvar current = FlowRouter.current();console.log(current);// prints following object// &#123;// path: \"/apps/this-is-my-app?show=yes&amp;color=red\",// params: &#123;appId: \"this-is-my-app\"&#125;,// queryParams: &#123;show: \"yes\", color: \"red\"&#125;// route: &#123;pathDef: \"/apps/:appId\", name: \"name-of-the-route\"&#125;// &#125; FlowRouter.watchPathChange()监听 path 的变化.如果你需要像使用 API 一样获得 params 或queryParams 可以用 FlowRouter.getQueryParam(). 123456Tracker.autorun(function() &#123; FlowRouter.watchPathChange(); var currentContext = FlowRouter.current(); // do anything with the current context // or anything you wish&#125;); FlowRouter.withReplaceState(fn)通常, 所有的 route 改变通过像 FlowRouter.go 和 FlowRouter.setParams() 这样的 APIs 添加 URL item 到浏览器的 history. 例如, 运行下面的代码: 123FlowRouter.setParams(&#123;id: \"the-id-1\"&#125;);FlowRouter.setParams(&#123;id: \"the-id-2\"&#125;);FlowRouter.setParams(&#123;id: \"the-id-3\"&#125;); 现在你可以点击浏览器的后退按钮2次. 这是常见的行为, 因为用户可以点击“后退”按钮, 并期待看到应用程序的前一个状态. 但是有些时候, 这不是你想要的. 你不需要污染浏览器 history. 那么, 你可以使用下面的语法. 12345FlowRouter.withReplaceState(function() &#123; FlowRouter.setParams(&#123;id: \"the-id-1\"&#125;); FlowRouter.setParams(&#123;id: \"the-id-2\"&#125;); FlowRouter.setParams(&#123;id: \"the-id-3\"&#125;);&#125;); 现在, 没有任何 item 在浏览器 history 中了. 就像 FlowRouter.setParams, 你可以使用任何 FlowRouter 的 API 在 FlowRouter.withReplaceState 里面. 我们命名这个功能为 withReplaceState , 因为, replaceState 是 underline API 用于此功能. 阅读更多关于 replace state &amp; the history API. FlowRouter.reload()FlowRouter routes 是幂等的. 这意味着, 即使你多次调用 FlowRouter.go() 到相同的 URL , 但是它只在第一次运行时激活. 这也是真实的直接点击路径. 因此, 如果你真的需要 reload 这个 route, 这个就是你想要的 API . FlowRouter.wait() and FlowRouter.initialize()在默认情况下, FlowRouter 初始化这个路由 process 在 Meteor.startup() 中回调. 对大多数app而言是这样工作. 但是, 一些 app 自定义初始化需要在 FlowRouter 初始化之后. 因此, FlowRouter.wait() 可以帮助你.你需要直接在 JavaScript 文件里调用. 然后, 当时的 app 准备好后调用 FlowRouter.initialize(). eg:- 12345// file: app.jsFlowRouter.wait();WhenEverYourAppIsReady(function() &#123; FlowRouter.initialize();&#125;); 查看更多信息访问 issue #180. FlowRouter.onRouteRegister(cb)这个 API 是特地为开发人员开发插件设计的. 他们可以监听任何 registered route 和为 FlowRouter 添加自定义功能. 这都工作在服务器端和客户端. 1234FlowRouter.onRouteRegister(function(route) &#123; // do anything with the route object console.log(route);&#125;); 让我们看一个为用户定义的route: 12345678FlowRouter.route('/blog/:post', &#123; name: 'postList', triggersEnter: [function() &#123;&#125;], subscriptions: function() &#123;&#125;, action: function() &#123;&#125;, triggersExit: [function() &#123;&#125;], customField: 'customName'&#125;); 这个 route 的 object 会这这样: 12345&#123; pathDef: '/blog/:post', name: 'postList', options: &#123;customField: 'customName'&#125;&#125; 因此, 这不是我们正在使用的内部 route object. Subscription Management对于订阅管理,我们强烈建议你遵循 Template/Component level subscriptions. 在这里查看 guide. FlowRouter 也有它自己的订阅管理机制. 我们将在 3.0 版本移除. 我们不排除 2.x 版本 因为这是实现你 APP FastRender 支持最简单的方法.在 3.0 版本我们更好的支持 FastRender 在服务端渲染. FlowRouter 只涉及 registration 和 subscriptions. 它不用等待 subscription 完成. 这是如何注册一个 subscription. 12345FlowRouter.route('/blog/:postId', &#123; subscriptions: function(params, queryParams) &#123; this.register('myPost', Meteor.subscribe('blogPost', params.postId)); &#125;&#125;); 我们也可以像这样全局注册 subscriptions : 123FlowRouter.subscriptions = function() &#123; this.register('myCourses', Meteor.subscribe('courses'));&#125;; 所有的全局 subscriptions 都运行在每一个 route 上. 因此, 在注册订阅是要特别注意命名. 然后你可以注册你的 subscriptions, 完成之后你可以检查 subscriptions 的状态: 1234Tracker.autorun(function() &#123; console.log(\"Is myPost ready?:\", FlowRouter.subsReady(\"myPost\")); console.log(\"Are all subscriptions ready?:\", FlowRouter.subsReady());&#125;); 因此, 你可以使用 FlowRouter.subsReady 在 template helpers 内部显示加载状态和相应的行为. FlowRouter.subsReady() with a callback有些时候, 我们需要使用 FlowRouter.subsReady() 在 autorun 中是不可用的. 这有一个事件处理的例子. 在这样的地方, 我们可以使用回调 API FlowRouter.subsReady(). 1234567Template.myTemplate.events(&#123; \"click #id\": function()&#123; FlowRouter.subsReady(\"myPost\", function() &#123; // do something &#125;); &#125;&#125;); Arunoda 有讨论更多关于订阅管理 FlowRouter, 在个博客里 this 这篇文章 FlowRouter and Subscription Management. 他展示了如何构建一个app: Fast RenderFlowRouter 支持 Fast Render. meteor add meteorhacks:fast-render 把 router.js 放在共享目录. 我们建议 lib/router.js. 你可以排除 Fast Render 支持通过包装 subscription registration 在 isClient 块: 1234567891011FlowRouter.route('/blog/:postId', &#123; subscriptions: function(params, queryParams) &#123; // using Fast Render this.register('myPost', Meteor.subscribe('blogPost', params.postId)); // not using Fast Render if(Meteor.isClient) &#123; this.register('data', Meteor.subscribe('bootstrap-data'); &#125; &#125;&#125;); Subscription Caching你也可以使用 Subs Manager 在客户端缓存 subscriptions . 我们没有有任何特别的事情来让它工作. 它应该像其他 routers 一样工作. IE9 SupportFlowRouter 支持 IE9. 但是它没有 HTML5 history polyfill. 因为大多数app不需要它. 如果你需要支持 IE9, 添加 HTML5 history polyfill 到你的packege. 1meteor add tomwasd:history-polyfill Hashbang URLs使用网址名 mydomain.com/#!/mypath 简单设置 hashbang 为 true在初始化的 function 中: 12345// file: app.jsFlowRouter.wait();WhenEverYourAppIsReady(function() &#123; FlowRouter.initialize(&#123;hashbang: true&#125;);&#125;); Prefixed paths例如,你希望在同一域名下运行多个web应用程序, 你可能会想在子路径在运行特定的 meteor application 服务 (eg example.com/myapp). 在这种情况下只包括路径前缀在 meteor ROOT_URL 的环境变量, FlowRouter 将会透明的处理没有任何额外参数的配置. Add-onsRouter 是基于 package 的 app. 其他项目像 useraccounts 需要 FlowRouter 支持. 否则, FlowRouter 很难用在真实项目中. 先在有很多 packages 都有 started to support FlowRouter. 因此, 你可以使用你喜欢的 FlowRouter package. 如果不是, 有一个叫 easy process 的包可以将它们转换为 FlowRouter. Add-on API 我们还发布了一个 new API 去支持开发者开发插件. 当用户在应用程序中创建一个路由时, 可以得到一个通知. 如果你有更多关于插件 API 的想法, 查看 let us know. Difference with Iron RouterFlowRouter 和 Iron Router 是两个不同的 routers. Iron Router 试图成为一个全功能的解决方案.它试图做每一件事包括 routing, subscriptions, rendering and layout management. FlowRouter 是一个简单的解决方案在 routing , UI performance 上. 它公开了有关功能的 APIs. 让我们了解更多的差别: RenderingFlowRouter 不处理渲染. 通过解耦渲染, 它可以使用任何渲染框架, 比如使用 Blaze Layout 进行动态模版渲染 .在路由动作中, 可以调用像 React 这样的布局框架. Subscriptions对于 FlowRouter, 我们强烈建议你使用 template/component layer subscriptions. 但是,如果你需要在路由器层做路由, FlowRouter 有 subscription registration 机制. 即使有, FlowRouter 永远不要等待 subscriptions 和 view layer 来做. Reactive Content在 Iron Router 你可以在 reactive content 里面使用 router, 但是任何一个 hook 或 method 可以以一个不可预测的方式重新运行. FlowRouter 限制； reactive 的数据源单个的运行; 当首先调用的时候. 我们认为这是可行当方法. Router 只是用户当 action. 我们可以在渲染层完成响应内容的工作. router.current() is evilRouter.current() 是邪恶的. 为什么? 让我们看看下面的这个例子.想象一下我们的 app 有这样一个 route: 1/apps/:appId/:section 现在让我们说,我们需要从 URL 获取 appId. 我们会这样做, 像在 Iron Router 一样. 123456Templates['foo'].helpers(&#123; \"someData\": function() &#123; var appId = Router.current().params.appId; return doSomething(appId); &#125;&#125;); 我们在 route 中改变 :section . 那么上面的方法也会重新运行. 如果我们增加一个 query param 到 URL, 它也会重新运行. 这是因为 Router.current() 会寻找改变 route(or URL). 但是在任何情况下, appId 不会改变. 因为这个, 我们到应用程序很多部分会重新运行,重新渲染. 这将会出现不可预测到渲染行为. FlowRouter 为修复次问题提供里 Router.getParam() API. 看看如何使用: 123456Templates['foo'].helpers(&#123; \"someData\": function() &#123; var appId = FlowRouter.getParam('appId'); return doSomething(appId); &#125;&#125;); No data contextFlowRouter 没有 data context. Data context 会有像 .current() 这样到问题. 我们相信, 它可以直接在 template (component) 层获取数据. Built in Fast Render SupportFlowRouter 已构建 Fast Render 支持. 只要天骄 Fast Render 到你到 app 它就会工作里. router 不需要做任何改变. 更多关于 check 信息的文档, 查看 docs. Server Side RoutingFlowRouter 是客户端 router 它不支持服务的路由. 但是 subscriptions 运行在服务的支持 Fast Render. Reason behind thatMeteor 不是一个从服务器直接发送 HTML 到客户端的传统开发框架. Meteor 最初需要发送一个特殊的 HTML 到客户端. 因此, 你不能直接向客户端发送一些东西. 此外, 相比于客户端, 在服务器端我们需要寻找一些不同的东西. 例如: 在服务器端我们必须处理头文件. 在服务器端我们必须处理像 GET, POST 这样类似的方法. 还有 Cookies. 因此, 最好使用服务器端专用的 router 像 meteorhacks:picker. 它支持连接和表达中间件, 并且它的 route 语法很简单. Server Side RenderingFlowRouter 3.0 将有服务器端渲染的支持. 我们已经开始了初步版本, 查看这个branch ssr. 这目前是非常有用的, Kadira 的 https://kadira.io 已经有在使用. Better Initial Loading Support在 Meteor 中, 我们要等到渲染之前发送所有到JS和其他资源. 这是一个问题. 在 3.0 版本, 在服务器端的支持下我们修复了它. Migrating into 2.0迁移到 2.0 版本是很容易到, 你不需要改变应用到任何代码,因为你已经在使用 2.0 版本的 APIs 了. 在 2.0 版本, 我们改变了名字和删除了一些过时的 APIs. 以下是将应用迁移到 2.0 版本的步骤. Use the New FlowRouter Package Now FlowRouter comes as kadira:flow-router So, remove meteorhacks:flow-router with : meteor remove meteorhacks:flow-router Then, add kadira:flow-router with meteor add kadira:flow-router Change FlowLayout into BlazeLayout 我们重新命名了 FlowLayout 为 BlazeLayout. 因此, 移除 meteorhacks:flow-layout 和添加 kadira:blaze-layout 即可. 你需要使用 BlazeLayout.render() 代替 FlowLayout.render() Stop using deprecated Apis 这没有中间件支持. 使用 triggers 代替. 这没有 API 叫 .reactiveCurrent(), 使用 .watchPathChange() 代替. 早些时候,你可以用 FlowRouter.current().params.query 访问和查询params. 但是, 现在你不能这样总了. 使用 FlowRouter.current().queryParams 代替.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}],"tags":[{"name":"FlowRouter","slug":"FlowRouter","permalink":"https://tkvern.com/tags/FlowRouter/"}],"keywords":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}]},{"title":"我的前端工作流","slug":"我的前端工作流","date":"2016-05-24T07:31:19.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160524/我的前端工作流/","link":"","permalink":"https://tkvern.com/20160524/我的前端工作流/","excerpt":"摩登时代在 Node.js 出现以前，以往的前端开发工作属于石器时代。而随着前端技术的大爆炸来临，我们需要赶上这一次潮流，加入到前端开发到摩登时代去。这篇博文主要是记录如何构建前端工作流。","text":"摩登时代在 Node.js 出现以前，以往的前端开发工作属于石器时代。而随着前端技术的大爆炸来临，我们需要赶上这一次潮流，加入到前端开发到摩登时代去。这篇博文主要是记录如何构建前端工作流。 开始先要具备Node.js的环境，安装NPM管理工具全局安装gulp1$ npm install gulp -g package.jsonnpm通过package.json文件来管理依赖。先进入的项目目录, 执行下面命令，一路回车即可。会生成名为package.json的文件。1$ npm init 导入包这个我构建好的json文件，将devDependencies下的所有节点复制过去。package.json123456789101112131415161718192021222324252627282930313233&#123; \"name\": \"ba\", \"version\": \"1.0.0\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"browser-sync\": \"^2.12.5\", \"coffee-script\": \"^1.10.0\", \"del\": \"^2.2.0\", \"gulp\": \"^3.9.1\", \"gulp-autoprefixer\": \"^3.1.0\", \"gulp-cache\": \"^0.4.4\", \"gulp-concat\": \"^2.6.0\", \"gulp-html-extend\": \"^1.1.6\", \"gulp-imagemin\": \"^2.4.0\", \"gulp-jshint\": \"^2.0.0\", \"gulp-livereload\": \"^3.8.1\", \"gulp-minify-css\": \"^1.2.4\", \"gulp-minify-html\": \"^1.0.6\", \"gulp-notify\": \"^2.2.0\", \"gulp-rename\": \"^1.2.2\", \"gulp-ruby-sass\": \"^2.0.6\", \"gulp-sitemap\": \"^4.1.1\", \"gulp-uglify\": \"^1.5.3\", \"gulp-watch\": \"^4.3.5\", \"jshint\": \"^2.9.2\" &#125;, \"description\": \"\"&#125; 完成之后安装这些包，版本如果有更新，去掉版本号默认会安装最稳定版本。安装时间视网络情况机器性能而定。首次安装时间比较长。1$ npm install 构建项目在当前目录下创建source文件夹同时为其创建子目录，如下结构，其中views目录下layouts用于视图模版，application用于视图文件1234567891011+ node_modules- source + img + js + scss - views + application + layouts gulpfile.coffee pacakge.json 构建模版视图模版使用gulp-html-extend进行解析，使用方法及配置可参考其官方文档。在layouts目录创建以下文件，如果有多套模版可以在layouts下创建子目录区分。12345678910111213- source + img + js + scss - views + application - layouts _meta.html _link.html _script.html _header.html _footer.html default.html @@include可将需要的局部模版导入@@placeholder可配置模版内容，下面例子会给出。source/layouts/default.html123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- @@placeholder= title --&gt; &lt;!-- @@include ./_meta.html --&gt; &lt;!-- @@include ./_link.html --&gt; &lt;!-- @@include ./_script.html --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"Wrapper\"&gt; &lt;!-- @@include ./_header.html --&gt; &lt;!-- @@placeholder= content --&gt; &lt;!-- @@include ./_footer.html --&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在此配置meata标签source/layouts/_meta.html1234&lt;meta charset=\"UTF-8\"&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;meta http-equiv=\"Content-Style-Type\" content=\"text/css\" /&gt;&lt;meta http-equiv=\"Content-Script-Type\" content=\"text/javascript\" /&gt; 在此配置link的内容，如css，font，icon等source/layouts/_link.html12&lt;link type=\"image/x-icon\" rel=\"shortcut icon\" href=\"/img/favicon.ico\"&gt;&lt;link href=\"/css/style.css\" type=\"text/css\" rel=\"stylesheet\" media=\"all\" /&gt; 在此配置需要的js文件source/layouts/_script.html12&lt;script src=\"/js/jquery-1.11.1.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script src=\"/js/index.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 在此配置头部内容source/layouts/_header.html123&lt;div class=\"page-header\"&gt; 我是头部&lt;/div&gt; 在此配置底部内容source/layouts/_footer.html123&lt;div class=\"page-footer\"&gt; 我是底部&lt;/div&gt; 到目前为止已经构建好视图模版了。 使用模版在application目录新建index.html文件@@master指定模版文件@@block自定义开始块@@close自定义结束块source/views/application1234567891011&lt;!-- @@master = ../layouts/default.html--&gt;&lt;!-- @@block = title--&gt;&lt;title&gt;我是标题&lt;/title&gt;&lt;!-- @@close--&gt;&lt;!-- @@block = content--&gt;&lt;div class=\"main\"&gt; 我是内容&lt;/div&gt;&lt;!-- @@close--&gt; 生成的文件内容如下1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;我是标题&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt; &lt;meta http-equiv=\"Content-Style-Type\" content=\"text/css\" /&gt; &lt;meta http-equiv=\"Content-Script-Type\" content=\"text/javascript\" /&gt; &lt;link type=\"image/x-icon\" rel=\"shortcut icon\" href=\"/img/favicon.ico\"&gt; &lt;link href=\"/css/style.css\" type=\"text/css\" rel=\"stylesheet\" media=\"all\" /&gt; &lt;script src=\"/js/jquery-1.11.1.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"/js/index.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"Wrapper\"&gt; &lt;div class=\"page-header\"&gt; 我是头部 &lt;/div&gt; &lt;div class=\"main\"&gt; 我是内容 &lt;/div&gt; &lt;div class=\"page-footer\"&gt; 我是底部 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 建立task完成模版构建之后，我们需要对网页对静态资源使用gulp进行处理。下面是我对gulp任务，使用CoffeeScript，然后我会讲解一个任务。有一点需要注意的地方，gulp-ruby-sass需要有ruby语言环境，这是安装传送门Ruby，一般Mac会自带Ruby。 gulpfile.coffee123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172gulp = require('gulp')del = require('del')cache = require('gulp-cache')uglify = require('gulp-uglify')concat = require('gulp-concat')jshint = require('gulp-jshint')broeserSync = require('browser-sync')sitemap = require('gulp-sitemap')imagemin = require('gulp-imagemin')sass = require('gulp-ruby-sass')minifycss = require('gulp-minify-css')extender = require('gulp-html-extend')minifyHTML = require('gulp-minify-html')autoprefixer = require('gulp-autoprefixer')gulp.task 'browser-sync', ['rebuild'], -&gt; broeserSync(&#123; server: &#123; baseDir: './dist/' &#125;, port: 8080, host: '0.0.0.0', ui: &#123; port: 8081 &#125; &#125;)gulp.task 'rebuild', -&gt; broeserSync.reload()gulp.task 'watch', -&gt; gulp.watch(['./dist/**/*.*'], ['rebuild']) gulp.watch(['./source/**/*.html'], ['extend']) gulp.watch(['./source/**/*.scss'], ['styles']) gulp.watch(['./source/**/*.js'], ['js']) gulp.watch(['./source/**/*.jpg','./source/**/*.png'], ['image'])gulp.task 'styles', -&gt; return sass('./source/scss/**/*.scss', &#123; style: 'compressed' &#125;) .pipe autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4') .pipe concat('style.css') .pipe minifycss() .pipe gulp.dest('./dist/css/')gulp.task 'extend', -&gt; gulp.src('./source/views/application/**/*.html') .pipe extender(&#123;annotations:false,verbose:false&#125;) .pipe minifyHTML() .pipe gulp.dest('./dist/')gulp.task 'js', -&gt; gulp.src('./source/**/*.js') .pipe uglify() .pipe gulp.dest('./dist/')gulp.task 'image', -&gt; gulp.src(['./source/**/*.jpg','./source/**/*.png']) .pipe cache(imagemin(&#123;optimizationLevel: 3, progressive: true, interlaced: true&#125;)) .pipe gulp.dest('./dist/')gulp.task 'clean', -&gt; del ['./dist/css','./dist/js','./dist/gallery', './dist/img', './dist/**/*.html']gulp.task 'sitemap', -&gt; gulp.src('dist/**/*.html', &#123; read: false &#125;) .pipe sitemap(&#123; siteUrl: 'http://yulive.cn' &#125;) .pipe gulp.dest('./dist/')gulp.task 'build', ['styles', 'js', 'image', 'extend']gulp.task 'default', ['browser-sync', 'watch'] styles任务，会将scss目录下的样式文件编译成css，然后autoprefixer方法会自动添加不同浏览器的前缀，concat合并成一个文件style.css后会使用minifycss压缩，最后输出到指定到目录gulp.dest。如果能看懂这个任务其他也都ok了。123456gulp.task 'styles', -&gt; return sass('./source/scss/**/*.scss', &#123; style: 'compressed' &#125;) .pipe autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4') .pipe concat('style.css') .pipe minifycss() .pipe gulp.dest('./dist/css/') extend任务会将模版文件解析并生成相应的htmljs压缩jsimage对图片资源进行无损压缩clean清空编译目录sitemap生成站点地图，便于SEOwatch监听文件，当发生改动时调用相应的任务build用于构建编译文件default默认任务，使用gulp命令执行的任务browser-sync用于开发环境实时更新页面，免去手动刷新的烦恼rebuild当资源文件更新时让browser-sync重新加载变更 完成这些之后，可以使用gulp + 任务名称执行相应的任务 结束语这是我的前端工作流，构建静态页面速度是不是一下子就提升了呢。","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}],"tags":[{"name":"Gulp","slug":"Gulp","permalink":"https://tkvern.com/tags/Gulp/"}],"keywords":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}]},{"title":"元编程之重写will_paginate","slug":"元编程之重写will-paginate","date":"2016-05-07T09:01:40.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160507/元编程之重写will-paginate/","link":"","permalink":"https://tkvern.com/20160507/元编程之重写will-paginate/","excerpt":"为什么重写will_paginate相信很多同学在使用will_paginate的时候都会遇到这样一个问题：自带分页样式太LOW了，有木有好看一点的，能不能自己定制呢。于是我们在RubyGems搜索will_paginate的主题gem包。发现有各种各样主题的，但却找不到你想要的，怎么办？","text":"为什么重写will_paginate相信很多同学在使用will_paginate的时候都会遇到这样一个问题：自带分页样式太LOW了，有木有好看一点的，能不能自己定制呢。于是我们在RubyGems搜索will_paginate的主题gem包。发现有各种各样主题的，但却找不到你想要的，怎么办？ 本着自己动手丰衣足食的理念，我们开始动手改造will_paginate。（注：笔者使用的是Materialize的前端框架，下文将以Materialize的分页为例） 预览效果先来看看will_paginate默认的效果是怎么样？为了方便后续区分，默认效果叫Old，修改后效果叫New上图中的Old分页稍显简陋。 下图是修改后需要New的效果 分析结构Old代码结构1234567891011121314151617&lt;div class=\"pagination\"&gt; &lt;a class=\"previous_page\" rel=\"prev\" href=\"/admins/admins?page=5\"&gt;← Previous&lt;/a&gt; &lt;a rel=\"start\" href=\"/admins/admins?page=1\"&gt;1&lt;/a&gt; &lt;a href=\"/admins/admins?page=2\"&gt;2&lt;/a&gt; &lt;a href=\"/admins/admins?page=3\"&gt;3&lt;/a&gt; &lt;a href=\"/admins/admins?page=4\"&gt;4&lt;/a&gt; &lt;a rel=\"prev\" href=\"/admins/admins?page=5\"&gt;5&lt;/a&gt; &lt;em class=\"current\"&gt;6&lt;/em&gt; &lt;a rel=\"next\" href=\"/admins/admins?page=7\"&gt;7&lt;/a&gt; &lt;a href=\"/admins/admins?page=8\"&gt;8&lt;/a&gt; &lt;a href=\"/admins/admins?page=9\"&gt;9&lt;/a&gt; &lt;a href=\"/admins/admins?page=10\"&gt;10&lt;/a&gt; &lt;span class=\"gap\"&gt;…&lt;/span&gt; &lt;a href=\"/admins/admins?page=24\"&gt;24&lt;/a&gt; &lt;a href=\"/admins/admins?page=25\"&gt;25&lt;/a&gt; &lt;a class=\"next_page\" rel=\"next\" href=\"/admins/admins?page=7\"&gt;Next →&lt;/a&gt;&lt;/div&gt; 从代码结构中可以知道，共有5种形式DOM: previous_page next_page current gap default 了解结构后，需要将Old修改成下面的结构才能有New的效果123456789 &lt;ul class=\"pagination\"&gt; &lt;li class=\"disabled\"&gt;&lt;a href=\"#!\"&gt;&lt;i class=\"material-icons\"&gt;chevron_left&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#!\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li class=\"waves-effect\"&gt;&lt;a href=\"#!\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li class=\"waves-effect\"&gt;&lt;a href=\"#!\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li class=\"waves-effect\"&gt;&lt;a href=\"#!\"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li class=\"waves-effect\"&gt;&lt;a href=\"#!\"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li class=\"waves-effect\"&gt;&lt;a href=\"#!\"&gt;&lt;i class=\"material-icons\"&gt;chevron_right&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 分析will_paginate源码将will_paginate的源码Clone到本地。进入lib目录下，这里就不介绍will_paginate到源码结构了，有时间自己看看。我们直奔主题，打开link_renderer.rb文件。我在里面添加了部分代码中文解释，对于修改结构已经够用了lib/will_paginate/view_helpers/link_renderer.rb123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138require 'cgi'require 'will_paginate/core_ext'require 'will_paginate/view_helpers'require 'will_paginate/view_helpers/link_renderer_base'module WillPaginate module ViewHelpers # This class does the heavy lifting of actually building the pagination # links. It is used by +will_paginate+ helper internally. class LinkRenderer &lt; LinkRendererBase # * +collection+ is a WillPaginate::Collection instance or any other object # that conforms to that API # * +options+ are forwarded from +will_paginate+ view helper # * +template+ is the reference to the template being rendered def prepare(collection, options, template) super(collection, options) @template = template @container_attributes = @base_url_params = nil end # Process it! This method returns the complete HTML string which contains # pagination links. Feel free to subclass LinkRenderer and change this # method as you see fit. def to_html html = pagination.map do |item| item.is_a?(Fixnum) ? page_number(item) : send(item) end.join(@options[:link_separator]) @options[:container] ? html_container(html) : html end # Returns the subset of +options+ this instance was initialized with that # represent HTML attributes for the container element of pagination links. def container_attributes @container_attributes ||= @options.except(*(ViewHelpers.pagination_options.keys + [:renderer] - [:class])) end protected # page_number方法显示分页元素 def page_number(page) unless page == current_page link(page, page, :rel =&gt; rel_value(page)) else tag(:em, page, :class =&gt; 'current') end end # gap方法在页数超过设定值时用...代替 def gap text = @template.will_paginate_translate(:page_gap) &#123; '&amp;hellip;' &#125; %(&lt;span class=\"gap\"&gt;#&#123;text&#125;&lt;/span&gt;) end # previous_page方法显示上一页 def previous_page num = @collection.current_page &gt; 1 &amp;&amp; @collection.current_page - 1 previous_or_next_page(num, @options[:previous_label], 'previous_page') end # next_page方法显示下一页 def next_page num = @collection.current_page &lt; total_pages &amp;&amp; @collection.current_page + 1 previous_or_next_page(num, @options[:next_label], 'next_page') end # 边界值按钮 def previous_or_next_page(page, text, classname) if page link(text, page, :class =&gt; classname) else tag(:span, text, :class =&gt; classname + ' disabled') end end def html_container(html) tag(:div, html, container_attributes) end # Returns URL params for +page_link_or_span+, taking the current GET params # and &lt;tt&gt;:params&lt;/tt&gt; option into account. def url(page) raise NotImplementedError end private def param_name @options[:param_name].to_s end # 私有方法, 构建a标签 def link(text, target, attributes = &#123;&#125;) if target.is_a? Fixnum attributes[:rel] = rel_value(target) target = url(target) end attributes[:href] = target tag(:a, text, attributes) end # 私有方法, 包裹标签 def tag(name, value, attributes = &#123;&#125;) string_attributes = attributes.inject('') do |attrs, pair| unless pair.last.nil? attrs &lt;&lt; %( #&#123;pair.first&#125;=\"#&#123;CGI::escapeHTML(pair.last.to_s)&#125;\") end attrs end \"&lt;#&#123;name&#125;#&#123;string_attributes&#125;&gt;#&#123;value&#125;&lt;/#&#123;name&#125;&gt;\" end def rel_value(page) case page when @collection.current_page - 1; 'prev' + (page == 1 ? ' start' : '') when @collection.current_page + 1; 'next' when 1; 'start' end end def symbolized_update(target, other) other.each do |key, value| key = key.to_sym existing = target[key] if value.is_a?(Hash) and (existing.is_a?(Hash) or existing.nil?) symbolized_update(existing || (target[key] = &#123;&#125;), value) else target[key] = value end end end end endend 打开类通过分析我们已经了解需要修改哪些方法 page_number previous_page next_page previous_or_next_page 同时我们还将使用两个私有方法 link(text, target, attributes = {}) tag(name, value, attributes = {}) 回到工作项目，新建文件。下面使用了元编程的法术——打开类。这也是作为动态语言的优点。修改过的地方我加了注释。lib/materialize_renderer.rb123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143require 'cgi'require 'will_paginate/core_ext'require 'will_paginate/view_helpers'require 'will_paginate/view_helpers/link_renderer_base'module WillPaginate module ViewHelpers # This class does the heavy lifting of actually building the pagination # links. It is used by +will_paginate+ helper internally. class LinkRenderer &lt; LinkRendererBase # * +collection+ is a WillPaginate::Collection instance or any other object # that conforms to that API # * +options+ are forwarded from +will_paginate+ view helper # * +template+ is the reference to the template being rendered def prepare(collection, options, template) super(collection, options) @template = template @container_attributes = @base_url_params = nil end # Process it! This method returns the complete HTML string which contains # pagination links. Feel free to subclass LinkRenderer and change this # method as you see fit. def to_html html = pagination.map do |item| item.is_a?(Fixnum) ? page_number(item) : send(item) end.join(@options[:link_separator]) @options[:container] ? html_container(html) : html end # Returns the subset of +options+ this instance was initialized with that # represent HTML attributes for the container element of pagination links. def container_attributes @container_attributes ||= @options.except(*(ViewHelpers.pagination_options.keys + [:renderer] - [:class])) end protected # 修改后，我使用私有方法tag，在link外面套了一层li，同时修改了class属性 def page_number(page) unless page == current_page # link(page, page, :rel =&gt; rel_value(page)) tag :li, link(page, page, :rel =&gt; rel_value(page)), :class =&gt; 'waves-effect' else # tag(:em, page, :class =&gt; 'current') tag(:li, link(page, '#!', :rel =&gt; rel_value(page)), :class =&gt; 'active') end end def gap text = @template.will_paginate_translate(:page_gap) &#123; '&amp;hellip;' &#125; %(&lt;span class=\"gap\"&gt;#&#123;text&#125;&lt;/span&gt;) end # 这里没有修改全局变量@options，使用打开类最好不要修改全局变量。所以直接改了icon def previous_page num = @collection.current_page &gt; 1 &amp;&amp; @collection.current_page - 1 # previous_or_next_page(num, @options[:previous_label], 'previous_page') previous_or_next_page(num, 'chevron_left', 'previous_page') end # 这里没有修改全局变量@options，使用打开类最好不要修改全局变量。所以直接改了icon def next_page num = @collection.current_page &lt; total_pages &amp;&amp; @collection.current_page + 1 # previous_or_next_page(num, @options[:next_label], 'next_page') previous_or_next_page(num, 'chevron_right', 'next_page') end # 修改了边界值的按钮，增加了局部变量icon_item用于google icon def previous_or_next_page(page, text, classname) icon_item = tag :i, text, :class =&gt; 'material-icons' if page # link(text, page, :class =&gt; classname) tag(:li, link(icon_item, page), :class =&gt; 'waves-effect') else # tag(:span, text, :class =&gt; classname + ' disabled') tag(:li, link(icon_item, '#!'), :class =&gt; 'disabled') end end def html_container(html) tag(:div, html, container_attributes) end # Returns URL params for +page_link_or_span+, taking the current GET params # and &lt;tt&gt;:params&lt;/tt&gt; option into account. def url(page) raise NotImplementedError end private def param_name @options[:param_name].to_s end def link(text, target, attributes = &#123;&#125;) if target.is_a? Fixnum attributes[:rel] = rel_value(target) target = url(target) end attributes[:href] = target tag(:a, text, attributes) end def tag(name, value, attributes = &#123;&#125;) string_attributes = attributes.inject('') do |attrs, pair| unless pair.last.nil? attrs &lt;&lt; %( #&#123;pair.first&#125;=\"#&#123;CGI::escapeHTML(pair.last.to_s)&#125;\") end attrs end \"&lt;#&#123;name&#125;#&#123;string_attributes&#125;&gt;#&#123;value&#125;&lt;/#&#123;name&#125;&gt;\" end def rel_value(page) case page when @collection.current_page - 1; 'prev' + (page == 1 ? ' start' : '') when @collection.current_page + 1; 'next' when 1; 'start' end end def symbolized_update(target, other) other.each do |key, value| key = key.to_sym existing = target[key] if value.is_a?(Hash) and (existing.is_a?(Hash) or existing.nil?) symbolized_update(existing || (target[key] = &#123;&#125;), value) else target[key] = value end end end end endend 加入到initializers完成上面的修改后，是不起作用的，还需要加入到initializers中，才会加载我们的打开类，新建文件config/initializers/will_pagination_materialize.rb1require 'materialize_renderer' 完成完成这些操作之后，重启服务器。恭喜你，完成了对will_paginate的修改。看看New吧","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://tkvern.com/categories/Ruby-on-Rails/"}],"tags":[{"name":"will_paginate","slug":"will-paginate","permalink":"https://tkvern.com/tags/will-paginate/"}],"keywords":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://tkvern.com/categories/Ruby-on-Rails/"}]},{"title":"为你的博客添加SSL","slug":"为你的博客添加SSL","date":"2016-04-25T11:58:20.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160425/为你的博客添加SSL/","link":"","permalink":"https://tkvern.com/20160425/为你的博客添加SSL/","excerpt":"为什么添加SSL好奇心总会驱使你去探索未知的东西，当完成Hexo博客构建之后，是不是给自己的博客添加SSL呢？在一定程度上HTTPS比HTTP更安全这是众所周知的，当然，使用HTTPS连接后，网页的第一次加载速度会较HTTP稍慢一些，但是并不影响后续请求的速度。所以SSL你还是值得一试。","text":"为什么添加SSL好奇心总会驱使你去探索未知的东西，当完成Hexo博客构建之后，是不是给自己的博客添加SSL呢？在一定程度上HTTPS比HTTP更安全这是众所周知的，当然，使用HTTPS连接后，网页的第一次加载速度会较HTTP稍慢一些，但是并不影响后续请求的速度。所以SSL你还是值得一试。 开始本文使用的是CloudFlare的免费SSL证书，如果你使用的是别的签书机构话，本文也可供参考。 注册CloudFlare注册传送门Sign-up。(如果地址无法打开，请确认你已翻墙。) 添加站点输入你的域名地址，点击Begin Scan 继续设置等待进度条完成，点击Continue Setup进行站点设置 设置DNS使用CloudFlare CDN加速设置Type A即可，设置相应的GitPages IP，完成后继续下一步。 选择Plan选择第一个Free，然后继续下一步 设置DNS解析地址将给出的DNS设置的相应的域名上 下面的我在阿里云设置后下效果 配置CNAME如果你的GitPages还没有配置，请在source目录下添加CNAME文件。 站点config配置如果你的站点有用到HTTP的资源，请修改为HTTPS。参考下面示例代码配置你的站点12345678910111213...# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://tkvern.com #填写你的域名enforce_ssl: tkvern.com #填写你的域名root: /permalink: :year:month:day/:title/permalink_defaults:... 重新部署12$ hexo clean$ hexo g -d 补充当配置完成后，等待一段时间，访问你的站点可能浏览器会提示HTTPS连接不安全，不用理会，继续等待24小时左右你就可以在你的站点看到绿色小钥匙了。","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://tkvern.com/tags/hexo/"}],"keywords":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}]},{"title":"Meteor项目部署笔记","slug":"Meteor项目部署笔记","date":"2016-04-25T07:15:30.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160425/Meteor项目部署笔记/","link":"","permalink":"https://tkvern.com/20160425/Meteor项目部署笔记/","excerpt":"记一次Meteor项目部署配置,使用 CentOS + Meteor + React + Mongdb + Nginx。node版本与Meteor依赖一致v0.10.43自定义服务配置比较麻烦，给出配置文件示例。","text":"记一次Meteor项目部署配置,使用 CentOS + Meteor + React + Mongdb + Nginx。node版本与Meteor依赖一致v0.10.43自定义服务配置比较麻烦，给出配置文件示例。 环境变量配置参数/etc/profile12345678export PATH=/usr/local/mongodb/bin:$PATHexport MONGO_URL=mongodb://localhost:27017/chatexport ROOT_URL=http://chat.haoduoshipin.comexport PORT=9000export PATH=/home/vagrant/.nvm/v0.10.43/bin:$PATHexport PATH=/usr/pgsql-9.4/bin/:$PATHexport PATH=/usr/bin:$PATHexport PATH=/usr/include/proj_api.h:$PATH 自定义服务:mongod/etc/init/mongod.conf12345678910111213141516# upstart service file at /etc/init/mongod.conf# When to start the servicestart on started sshd and runlevel [2345]# When to stop the servicestop on shutdown# Automatically restart process if crashedrespawnrespawn limit 10 5script export PATH=/usr/local/mongodb/bin:/opt/local/bin:/opt/local/sbin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin exec mongod &gt;&gt; /home/vagrant/logs/mongod.logend script 自定义服务:chat/etc/init/chat.conf123456789101112131415161718192021222324252627282930# upstart service file at /etc/init/chat.conf# When to start the servicestart on started mongod and runlevel [2345]# When to stop the servicestop on shutdown# Automatically restart process if crashedrespawnrespawn limit 10 5script export PATH=/home/vagrant/.nvm/v0.10.43/bin:/opt/local/bin:/opt/local/sbin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin # set to home directory of the user Meteor will be running as export PWD=/home/vagrant export HOME=/home/vagrant # leave as 127.0.0.1 for security export BIND_IP=127.0.0.1 # the port nginx is proxying requests to export PORT=9000 # this allows Meteor to figure out correct IP address of visitors export HTTP_FORWARDED_COUNT=1 # MongoDB connection string using meteor as database name export MONGO_URL=mongodb://localhost:27017/chat # The domain name as configured previously as server_name in nginx export ROOT_URL=http://chat.haoduoshipin.com exec node /home/vagrant/chat/bundle/main.js &gt;&gt; /home/vagrant/chat/chat.logend script nginx代理配置/usr/local/nginx/conf/vhost/chat.conf123456789101112131415server &#123; listen 80; server_name chat.com; location / &#123; proxy_pass http://localhost:9000; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_x_forwarded_host; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_read_timeout 3m; proxy_send_timeout 3m; &#125;&#125; 在CentOS6.5中启动自定义服务1$ initctl 启动自定义mongdb服务1$ sudo initctl start mongod 启动chat服务1$ sudo initctl chat mongod 启动nginx服务1$ sudo service nginx start mongdb使用123456789101112$ mongo&gt; show dbschat 0.000GBlocal 0.000GB&gt; use chatswitched to db chat&gt; show collectionsusers...&gt; db.users.find() nginx 代理监听端口9000 外部访问地址http://chat.com:8080","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}],"tags":[{"name":"Meteor","slug":"Meteor","permalink":"https://tkvern.com/tags/Meteor/"}],"keywords":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}]},{"title":"从WordPress到hexo的必经之路","slug":"从WordPress到hexo的必经之路","date":"2016-04-20T13:26:49.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160420/从WordPress到hexo的必经之路/","link":"","permalink":"https://tkvern.com/20160420/从WordPress到hexo的必经之路/","excerpt":"前言本来不打算写关于hexo教程的，Google上关于hexo的文章到处都有，重复造轮子的事情本身意义不大。之前的博客一直使用的是WordPress，朋友说用WordPress来做博客会存在种种问题，WP就像是一把瑞士军刀，在灵巧以及功能性上已经失去了平衡。然后去尝试了各种博客构建方案，折腾完后发现，Hexo已经在简洁之道上了。","text":"前言本来不打算写关于hexo教程的，Google上关于hexo的文章到处都有，重复造轮子的事情本身意义不大。之前的博客一直使用的是WordPress，朋友说用WordPress来做博客会存在种种问题，WP就像是一把瑞士军刀，在灵巧以及功能性上已经失去了平衡。然后去尝试了各种博客构建方案，折腾完后发现，Hexo已经在简洁之道上了。 开始构建node和npm的环境肯定是必不可少的 node使用nvm安装，方便快捷 》》nvm安装详解 npm是随同node一起的包管理工具，如果安装的是最新版的node就不用安装了，但是需要了解一些关于npm的命令》》npm命令详解 准备好环境后就可以传送到hexo到官网》》hexo安装详解 如果不着急到话，可以先看看下面的内容，能帮你避免一些hexo的问题。 使用安装完成后就可以创建你的博客了。 执行hexo g --watch资源无法同步如果你想在文章资源更新后能马上同步资源，那就不要在虚拟机运行就行了。下面给出代码示例： 1$ hexo g --watch 1$ hexo server 配置_config.yml文件打开localhost:4000后会有一个hello world文件，那么恭喜你，你已经构建好了一个博客。对于大多数人来说看到hexo的文件目录都会有些困惑。该从哪里入手？ 打开_config.yml文件，大部分的参数默认即可。简单晒下我的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: #站点名称subtitle: #副标题description: #站点描述author: #作者名称language: #语言默认en， 可设置为 zh-Hanstimezone: #时区，可设置为 Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: #站点域名root: / #博客根目录permalink: #持久链接格式，可设置为 :year:month:day/:title/ permalink_defaults: #同上，不过可以忽略# Directorysource_dir: source #文章目录public_dir: public #编译目录tag_dir: tags #标签目录archive_dir: archives #档案目录category_dir: categories#类别目录code_dir: downloads/code#代码下载目录i18n_dir: :lang skip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: nextsstylus: compress: true# Avataravatar: https://avatars1.githubusercontent.com/u/10667077?v=3&amp;s=460#duoshuoduoshuo_shortname: # Deployment## Docs: https://hexo.io/docs/deployment.html## 部署必须配置，填写相应都仓库地址，最好把本机都ssh密匙添加到github中deploy: type: git repo: branch: master message:swiftype_key: google_site_verification: sitemap: path: sitemap.xmlqiniu: offline: true sync: true bucket: blog access_key: secret_key: dirPrefix: static urlPrefix: # urlPrefix: local_dir: public update_exist: true image: folder: images extend: js: folder: js css: folder: css 然后你就可以开始写作了，如果还想配置更多自定义的内容，可以安装一些插件，主题推荐使用NexT。其他的不建议折腾了。 文章列表显示摘要在需要截取的地方加上&lt;!-- more --&gt;即可。 使用七牛云存储CDN如果你看到有文章推荐你使用hexo-qiniu-sync这个插件，千万不要去尝试这个插件，并发问题非常多，简直会让你奔溃。如果真的要使用建议做好文件备份，以免意外发生。那怎么办呢？去下载qrsync 命令行上传同步工具。通过手动方式将public目录传到七牛云存储，再修改所使用主题到link script地址配置。 使用多说多说到加载速度是比较慢，自己权衡利弊吧。NexT主题集成了多说到配置，去多说添加个站点就好了，把多说到name填写到duoshuo_shortname即可。 使用站内搜索 Next也集成了swiftype到站内搜索，由于swiftype是国外的资源，所以加载也会比较慢。填写swiftype_key参数完成配置 使用打赏在主题配置文件中加入以下字段，获取支付宝二维码12reward_comment: #打赏内容描述alipay: #自己的支付宝二维码图片地址 配置gulp.coffee文件主题目录下的gulp.coffee定义了一个js检查任务，如果需要对主题对静态资源做处理请查看gulp详解。对于新手来说，一般不建议再处理这些资源。 添加robots.txt当需要对爬虫抓取做些处理时，在项目根目录的source中创建robots.txt即可，下面是示例代码:12345678910111213141516# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: #填写完整域名地址 http://example.com/sitemap.xml 映射域名在根目录的source下面创建CNAME文件，在其中填写你要映射的域名。将域名解析到统一地址103.245.222.133。之后需要等待一段时间DNS才能解析完成。 部署如果没有改动主题资源，那么部署的时候不用每次都hexo clean。直接执行下面都命令完成部署。1$ hexo g -d","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://tkvern.com/tags/hexo/"}],"keywords":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}]},{"title":"Rails + PostgreSQL 常见问题及解决办法","slug":"Rails + PostgreSQL 常见问题及解决办法","date":"2016-04-18T13:26:49.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160418/Rails + PostgreSQL 常见问题及解决办法/","link":"","permalink":"https://tkvern.com/20160418/Rails + PostgreSQL 常见问题及解决办法/","excerpt":"No pg_config… 问题重现: 在bundle的时候出现gem包pg-0.18.4安装出错的情况，错误代码如下:","text":"No pg_config… 问题重现: 在bundle的时候出现gem包pg-0.18.4安装出错的情况，错误代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758$ bundle...Gem::Ext::BuildError: ERROR: Failed to build gem native extension. current directory: /home/vagrant/.rvm/gems/ruby-2.3.0/gems/pg-0.18.4/ext/home/vagrant/.rvm/rubies/ruby-2.3.0/bin/ruby -r ./siteconf20160415-7139-1cu08ba.rb extconf.rbchecking for pg_config... noNo pg_config... trying anyway. If building fails, please try again with --with-pg-config=/path/to/pg_configchecking for libpq-fe.h... noCan't find the 'libpq-fe.h header*** extconf.rb failed ***Could not create Makefile due to some reason, probably lack of necessarylibraries and/or headers. Check the mkmf.log file for more details. You mayneed configuration options.Provided configuration options: --with-opt-dir --without-opt-dir --with-opt-include --without-opt-include=$&#123;opt-dir&#125;/include --with-opt-lib --without-opt-lib=$&#123;opt-dir&#125;/lib --with-make-prog --without-make-prog --srcdir=. --curdir --ruby=/home/vagrant/.rvm/rubies/ruby-2.3.0/bin/$(RUBY_BASE_NAME) --with-pg --without-pg --enable-windows-cross --disable-windows-cross --with-pg-config --without-pg-config --with-pg_config --without-pg_config --with-pg-dir --without-pg-dir --with-pg-include --without-pg-include=$&#123;pg-dir&#125;/include --with-pg-lib --without-pg-lib=$&#123;pg-dir&#125;/libTo see why this extension failed to compile, please check the mkmf.log which can be found here: /home/vagrant/.rvm/gems/ruby-2.3.0/extensions/x86_64-linux/2.3.0/pg-0.18.4/mkmf.logextconf failed, exit code 1Gem files will remain installed in /home/vagrant/.rvm/gems/ruby-2.3.0/gems/pg-0.18.4 for inspection.Results logged to /home/vagrant/.rvm/gems/ruby-2.3.0/extensions/x86_64-linux/2.3.0/pg-0.18.4/gem_make.out...An error occurred while installing pg (0.18.4), and Bundler cannot continue.Make sure that `gem install pg -v '0.18.4'` succeeds before bundling. 解决方案: 先不要急着按提示去执行，出现这个问题可能是你没有安装PostgreSQL或是没有指定pgsql的路径。如果没有安装PostgreSQL，点击传送门去安装(注意：执行yum install postgresql-server后继续往下看文档安装pgsql的扩展，建议最好安装的PostgreSQL是9.X以上版本，否则许多新特性无法使用)。英文不太好的同学可以到这篇博客PostgreSQL新手入门看看。步骤1:安装libpq-dev包Ubuntu执行以下命令：1$ apt-get install libpq-dev CentOS/RetH执行以下命令：1$ yum install postgresql-devel 步骤2:找到你的pgsql安装目录我的是在/usr/pgsql-9.4，也有可能会在/usr/local/pgsql，因系统而异。 步骤3:with-pg-config后面接的就是pgsql目录下的pg_config文件，注意--with-pg-config前面还有两个-1$ gem install pg -v &apos;0.18.4&apos; -- --with-pg-config=/usr/pgsql-9.4/bin/pg_config 步骤4:重新执行bundle命令 无法连接pgsql问题重现: 运行rails s -b 0.0.0.0 -p 3000后，在浏览器打开项目首页出现下面问题 12345678910PG::ConnectionBad (FATAL: Ident authentication failed for user \"postgres\"): activerecord (4.2.3) lib/active_record/connection_adapters/postgresql_adapter.rb:655:in `initialize' activerecord (4.2.3) lib/active_record/connection_adapters/postgresql_adapter.rb:655:in `new' activerecord (4.2.3) lib/active_record/connection_adapters/postgresql_adapter.rb:655:in `connect' activerecord (4.2.3) lib/active_record/connection_adapters/postgresql_adapter.rb:242:in `initialize' activerecord-postgis-adapter (3.1.0) lib/active_record/connection_adapters/postgis_adapter.rb:51:in `initialize'... 解决方案:找到 pg_hba.conf文件, 一般是在/var/lib/pgsql/data目录下，如果修改后不生效看看/var/lib/pgsql目录下是否还有其他的数据目录。因系统环境而异。使用vim或vi打开步骤1:1$ vim /var/lib/pgsql/data/pg_hba.conf 步骤2:按住shift + g 将光标定位的文件底部，按i进入编辑模式，修改METHOP为md5验证。完成后按shift + : 进入命令模式，输入wq完成编辑。下面给出修改后效果1234567891011...# TYPE DATABASE USER CIDR-ADDRESS METHOD# &quot;local&quot; is for Unix domain socket connections onlylocal all all md5# IPv4 local connections:host all all 127.0.0.1/32 md5# IPv6 local connections:host all all ::1/128 md5 步骤3:重启postgresql服务1$ service postgresql restart type “json” does not exist问题重现: 执行rake db:migrate时出现错误，错误代码如下：1234567891011121314$ rake db:migrate...== 20151208044806 CreateShops: migrating ======================================-- create_table(:shops)rake aborted!StandardError: An error has occurred, this and all later migrations canceled:PG::UndefinedObject: ERROR: type \"json\" does not existLINE 1: ...ying NOT NULL, \"logo\" character varying, \"images\" json, \"reg...... 解决方案：出现这种问题大多是因为安装了老版的PostgreSQL，在CentOS上面执行yum install postgresql默认是8.X版本。升级版本即可。 步骤1:删除旧版postgresql1$ yum remove postgresql* 步骤2:更新yum1$ yum update 步骤3: 到http://yum.pgrpms.org/reporpms/选择9.X以上版本下载相应的rpm包1$ wget https://download.postgresql.org/pub/repos/yum/9.4/redhat/rhel-6-x86_64/pgdg-centos94-9.4-2.noarch.rpm 步骤4:使用下载好的rpm包1$ rpm -ivh pgdg-centos94-9.4-2.noarch.rpm 步骤5:安装postgresql94-server1yum -y install postgresql94-server 步骤6:重新启动postgresql-94服务1$ service postgresql-9.4 start type “geography” does not exist问题重现:执行rake db:migrate时出现错误，错误代码如下： 123456789101112$ rake db:migrate...rake aborted!StandardError: An error has occurred, this and all later migrations canceled:PG::UndefinedObject: ERROR: type \"geography\" does not existLINE 1: ... \"address\" character varying NOT NULL, \"location\" geography(...... 解决方案: 这是由于没有安装支持geography类型数据的扩展，笔者使用的是PostgreSQL-9.4版本，这里给出9.X版本的解决方案。为了后续用到其他扩展方便，这里也就一起安装了。 步骤1: list命令查看postgresql有哪些扩展，当你看到下面效果说明你的yum库中有这些扩展，如果没有请到http://yum.pgrpms.org/reporpms/选择9.X以上版本下载相应的rpm包安装。如果不需要请跳过步骤1，步骤21234567891011121314151617181920212223242526272829$ yum list postgresql94-*已加载插件：fastestmirrorRepository pgdg94 is listed more than once in the configurationRepository pgdg94-source is listed more than once in the configurationLoading mirror speeds from cached hostfile * base: mirrors.yun-idc.com * extras: mirrors.yun-idc.com * updates: mirrors.yun-idc.com已安装的软件包postgresql94.x86_64 9.4.7-1PGDG.rhel6 @pgdg94postgresql94-libs.x86_64 9.4.7-1PGDG.rhel6 @pgdg94postgresql94-server.x86_64 9.4.7-1PGDG.rhel6 @pgdg94可安装的软件包postgresql94-contrib.x86_64 9.4.7-1PGDG.rhel6 pgdg94 postgresql94-debuginfo.x86_64 9.4.7-1PGDG.rhel6 pgdg94 postgresql94-devel.x86_64 9.4.7-1PGDG.rhel6 pgdg94 postgresql94-docs.x86_64 9.4.7-1PGDG.rhel6 pgdg94 postgresql94-jdbc.x86_64 9.3.1101-1PGDG.rhel6 pgdg94 postgresql94-jdbc-debuginfo.x86_64 9.3.1101-1PGDG.rhel6 pgdg94 postgresql94-odbc.x86_64 09.03.0400-1PGDG.rhel6 pgdg94 postgresql94-odbc-debuginfo.x86_64 09.03.0400-1PGDG.rhel6 pgdg94 postgresql94-plperl.x86_64 9.4.7-1PGDG.rhel6 pgdg94 postgresql94-plpython.x86_64 9.4.7-1PGDG.rhel6 pgdg94 postgresql94-pltcl.x86_64 9.4.7-1PGDG.rhel6 pgdg94 postgresql94-python.x86_64 4.2-1PGDG.rhel6 pgdg94 postgresql94-python-debuginfo.x86_64 4.2-1PGDG.rhel6 pgdg94 postgresql94-tcl.x86_64 2.1.1-1.rhel6 pgdg94 postgresql94-tcl-debuginfo.x86_64 2.1.1-1.rhel6 pgdg94 postgresql94-test.x86_64 步骤2:安装扩展1$ sudo yum install postgresql94-* 步骤3: 前往postgis安装扩展。友情提示：自行编译源码的话，如果系统编译环境不完全，会折腾很久，建议直接用yum安装。推荐一篇文章centos安装postgis 。作者是为PostgreSQL源加上EPEL源，直接yum安装，无痛解决依赖问题。抓狂的同学速度get。如果依然报错，请执行rake db:drop，然后再创建一次数据库就行了。","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://tkvern.com/categories/Ruby-on-Rails/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://tkvern.com/tags/PostgreSQL/"}],"keywords":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://tkvern.com/categories/Ruby-on-Rails/"}]},{"title":"Arduino-uno从入门1","slug":"Arduino-uno从入门1","date":"2016-04-16T13:26:49.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160416/Arduino-uno从入门1/","link":"","permalink":"https://tkvern.com/20160416/Arduino-uno从入门1/","excerpt":"准备学习物联网开发，我们需要有良好的社区支持，方便的配件采购渠道和便宜的价格。而Arduino刚好具备了这些条件。 知识储备在开发Arduino之前你需要掌握基础的C语言知识。当然如果你已经有过Java，PHP，Ruby，Python，Javascript类似的语言开发经历的话请继续往下。除了编程基础以外你还需要了解基本的电学知识，大多数高中物理教材都有这些知识，你同样可以借助搜索引擎帮助你获得这些知识。","text":"准备学习物联网开发，我们需要有良好的社区支持，方便的配件采购渠道和便宜的价格。而Arduino刚好具备了这些条件。 知识储备在开发Arduino之前你需要掌握基础的C语言知识。当然如果你已经有过Java，PHP，Ruby，Python，Javascript类似的语言开发经历的话请继续往下。除了编程基础以外你还需要了解基本的电学知识，大多数高中物理教材都有这些知识，你同样可以借助搜索引擎帮助你获得这些知识。这里推荐一个学习C语言的链接:慕课网-C语言入门 学习资料在Arduino官网提供了诸多的编程参考，社区贡献代码库和详细的文档。如果觉得文档不够明白，没关系。推荐到极客学院-Arduino开发 查看相关视频。在硬件还没到货之前可以在极客学院先了解一些关于Arduino的知识。 硬件采购在Arduino的官网提供了购买链接，但是如果你觉得麻烦的话推荐到淘宝店慧净电子购买套装。购买时请注意，慧净电子提供的Arduino uno有两种版本，一个是国产的相对便宜，一个是进口的相对贵一些。功能上没有区别只是一个是国内生产，一个是国外生产。如果不介意建议购买国产版本。笔者购买的链接参考:基于Arduino智能小车循迹避障智能小车 UNO R3入门 机器人套件 环境搭建如果你使用的是Windows，环境搭建想对简单，如果是Mac可能会存在Arduino uno连接后找不到端口的问题，稍后会给出解决方案。 下载ArduinoIDE开源的Arduino软件（IDE）让编程和下载程序变得非常简单。这个软件能够运行在Windows、Mac OS X以及Linux上，软件基于Processing和其他的开源软件，使用java开发完成。这个软件适用于任何Arduino控制板下载连接：https://www.arduino.cc/en/Main/Software 安装Arduino驱动解决在Mac上找不到端口问题How To Use Cheap Chinese Arduinos That Come With With CH340G / CH341G Serial/USB Chip下载文件 CH34x_Install.zip解压后安装，重启。重新插上Arduino数据线就可以在ArduinoIDE中看到设备了 温馨提示如果你有使用SublimeText，千万不要安装插件arduino-like IDE。安装arduino-cli就足够了。代码编译下载最好是使用ArduinoIDE完成，如果需要使用SublimeText，在选项中开启使用外部编辑器就好了，不然你会浪费很多时间在编辑器上面。强烈建议先看完极客学院的Arduino课程后再实操，结合笔者的后续文档，少踩很多坑。。。","categories":[{"name":"智能硬件","slug":"智能硬件","permalink":"https://tkvern.com/categories/智能硬件/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://tkvern.com/tags/Arduino/"}],"keywords":[{"name":"智能硬件","slug":"智能硬件","permalink":"https://tkvern.com/categories/智能硬件/"}]},{"title":"进击Drupal-2","slug":"进击Drupal-2","date":"2016-03-21T14:26:49.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160321/进击Drupal-2/","link":"","permalink":"https://tkvern.com/20160321/进击Drupal-2/","excerpt":"安装Drupal常用模块","text":"安装Drupal常用模块 ctools其他模块会依赖这个模块 12$ drush dl ctools $ drush en ctools -y views用于创建各种形式的列表 12$ drush dl views $ drush en views views_ui -y rules执行设定任务 12$ drush dl rules $ drush en rules rules_admin -y flag标识模块 12$ drush dl flag $ drush en flag -y token依赖模块 12$ drush dl token $ drush en token -y pathauto定义内容地址模式 12$ drush dl pathauto $ drush en pathauto -y jquery_update升级Drupal自带jquery版本，这里选择7.x-2.x-dev版本 123456789$ drush dl jquery_update //选择4Choose one of the available releases for jquery_update: [0] : Cancel [1] : 7.x-3.0-alpha3 - 2015-Oct-20 - Supported [2] : 7.x-3.x-dev - 2015-Oct-20 - Development [3] : 7.x-2.7 - 2015-Oct-20 - Security, Supported, Recommended [4] : 7.x-2.x-dev - 2015-Oct-20 - Development [5] : 7.x-1.x-dev - 2013-Sep-30 - Development$ drush en jquery_update -y libraries共享类库 12$ drush dl libraries $ drush en libraries -y module_filter更友好的模块管理界面 12$ drush dl module_filter $ drush en module_filter -y l10n_update翻译模块 12$ drush dl l10n_update $ drush en l10n_update -y 使用l10n_update命令123$ drush | grep l10n$ drush l10n-update-refresh$ drush l10n-update 管理主题本节会配置一下基本的主题搭配 安装 adminimal_theme 开发版输入下面命令，选择[1] 123$ drush dl adminimal_theme --select //选择[1]$ drush en adminimal -ydrush vset admin_theme adminimal //设置主题","categories":[{"name":"php","slug":"php","permalink":"https://tkvern.com/categories/php/"}],"tags":[{"name":"Drupal","slug":"Drupal","permalink":"https://tkvern.com/tags/Drupal/"}],"keywords":[{"name":"php","slug":"php","permalink":"https://tkvern.com/categories/php/"}]},{"title":"进击Drupal-1","slug":"进击Drupal-1","date":"2016-03-21T13:26:49.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160321/进击Drupal-1/","link":"","permalink":"https://tkvern.com/20160321/进击Drupal-1/","excerpt":"环境准备首先我们需要有一台CentOS6.5以上的主机，如果你还没有使用过Linux的话，本教程就不太适用了。。 使用Drupal需要Nginx PHP MySQL这些东西，如果觉得安装麻烦可以使用lnmp进行一键安装，","text":"环境准备首先我们需要有一台CentOS6.5以上的主机，如果你还没有使用过Linux的话，本教程就不太适用了。。 使用Drupal需要Nginx PHP MySQL这些东西，如果觉得安装麻烦可以使用lnmp进行一键安装， 推荐两个安装链接: LNMP一键安装包 LNMP一键安装－支援PHP7 安装方法不再敖述，上面的链接附带教程。有了lnmp环境就可以开始下一步 安装PHP扩展这些扩展在使用drush和Drupal的时候需要用到，所以一定要装好。 查看服务状态 1234$ service php-fpm statusphp-fpm (pid 4054) is running... 安装常用扩展 php-gd 图像处理 php-mysqlnd mysqlnd服务相关 php-pdo 数据库相关 php-mcrypt 加密相关 php-mbstring 多子节字符处理 php-xmlrpc xml相关 php-jsonc json处理 12$ yum install php-gd php-mysqlnd php-pdo php-mcrypt php-mbstring php-xmlrpc php-jsonc -y 重启php-fpm服务安装完扩展后需要重启服务生效 12$ service php-fpm restart 安装PHP包管理工具ComposerComposer可以方便的管理PHP的依赖 执行下面命令会下载一个叫composer.phar的文件 1234$ cd ~$ curl -sS https://getcomposer.org/installer | php 可以通过php composer.phar查看composer的命令帮助。为了方便使用composer命令，将composer.phar放到系统根目录执行。 12$ mv composer.phar /usr/local/bin/composer 安装DrushDrush命令行主要为了管理Drupal，这里使用Drush开发版 12$ composer global require drush/drush:dev-master 查看Drush安装目录 12$ ll ~/.composer/vendor/drush/drush/ 将Drush添加到环境变量中 12$ vim ~/.bash_profile 12345678910111213141516171819202122# .bash_profile# Get the aliases and functionsif [ -f ~/.bashrc ]; then^I. ~/.bashrcfi# User specific environment and startup programsPATH=$PATH:$HOME/bin# －－－－－－将drush到路径插入到环境变量－－－－－－export PATH=$HOME/.composer/vendor/bin:$PATHexport PATH=$PATH:/usr/pgsql-9.4/bin[[ -s \"$HOME/.rvm/scripts/rvm\" ]] &amp;&amp; source \"$HOME/.rvm/scripts/rvm\" # Load RVM into a shell session *as a function* 更新环境变量 12$ source ~/.bash_profile 使用drush，如果能看到命令提示代表你已经安装成功 123456789101112$ drushExecute a drush command. Run `drush help [command]` to view command-specific help. Run `drush topic` to read even more documentation.Global options (see `drush topic core-global-options` for the full list):... 开启Drupal完成上面的准备后就可以开启Drupal了 创建Drupal项目第一步,在项目目录下载drupal。目前有部分modules不支持8.x以上版本，所以我们在这里指定drupal-7.43 12$ drush dl drupal-7.43 第二步，进入到drupal目录下载中文简体语言包，并保存到profiles/standard/translations/。 如果需要更多语言支持，请查看－－Drupal Translations 12$ wget http://ftp.drupal.org/files/translations/7.x/drupal/drupal-7.43.zh-hans.po -P profiles/standard/translations/ 第三步，创建drupal需要到数据库 12345678910111213141516$ mysql -u root -pWelcome to the MySQL monitor....mysql&gt; create database drupal;mysql&gt; grant all privileges on drupal.* to 'drupal'@'localhost' identified by '&lt;你的密码&gt;';mysql&gt;exit 第四步，配置Drupal站点，将&lt; &gt;符号的内容替换(包括&lt; &gt;) 12$ drush si standard --db-url=mysql://drupal:&lt;数据库密码&gt;@localhost/drupal --site-name=&lt;站点名称&gt; --site-mail=&lt;站点邮箱&gt; --locale=zh-hans --account-name=&lt;管理员账号&gt; --account-pass=&lt;管理员密码&gt; --account-mail=&lt;管理员邮箱&gt; -v 第五步，配置Nginx服务器 编辑/usr/local/nginx/conf/drupal.conf，如果没有就创建一个，然后将相应的server_name root填入。 /usr/local/nginx/conf/drupal.conf 123456789101112131415161718192021222324252627282930server &#123;listen 80;server_name web-stack.drupal.local;root /vagrant_data/drupal;index index.php index.html;access_log ^Ion;location / &#123;try_files $uri $uri/ /index.php?$query_string;&#125;location ~ \\.php$ &#123;fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;include fastcgi.conf;&#125;&#125; 如果是在vagrant 虚拟机里面，需要将drupal.conf放到/usr/local/nginx/conf/vhost/drupal.conf。 然后修改php-fpm的配置，将默认的listen.owner listen.group user group 修改为vagrant。 将listen 改为 127.0.0.1:9000。 配置详细见下面代码片段 12$ sudo vim /usr/local/php/etc/php-fpm.conf /usr/local/php/etc/php-fpm.conf 123456789101112131415161718192021222324252627282930313233343536373839404142[global]pid = /usr/local/php/var/run/php-fpm.piderror_log = /usr/local/php/var/log/php-fpm.loglog_level = notice[www]listen = 127.0.0.1:9000listen.backlog = -1listen.allowed_clients = 127.0.0.1listen.owner = vagrantlisten.group = vagrantlisten.mode = 0666user = vagrantgroup = vagrantpm = dynamicpm.max_children = 10pm.start_servers = 2pm.min_spare_servers = 1pm.max_spare_servers = 6request_terminate_timeout = 100request_slowlog_timeout = 0slowlog = var/log/slow.log 然后重启服务 12$ sudo lnmp restart 第六步，修改hosts 如果你已经配好了就可以省略。配置完成后就可以在浏览器通过http://web-stack.drupal.local/访问了 12$ sudo vim /etc/hosts 在末尾添加，代码如下： /etc/hosts 12345678...127.0.0.1 web-stack.drupal.local 温馨提示，如果是在vagrant虚拟机里面还需要修改端口映射，将80端口映射到主机中 完成之后就可以看到下图效果了","categories":[{"name":"php","slug":"php","permalink":"https://tkvern.com/categories/php/"}],"tags":[{"name":"Drupal","slug":"Drupal","permalink":"https://tkvern.com/tags/Drupal/"}],"keywords":[{"name":"php","slug":"php","permalink":"https://tkvern.com/categories/php/"}]},{"title":"wysiwyg-rails-编辑器支援七牛云存储","slug":"wysiwyg-rails-编辑器支援七牛云存储","date":"2016-03-20T13:26:49.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160320/wysiwyg-rails-编辑器支援七牛云存储/","link":"","permalink":"https://tkvern.com/20160320/wysiwyg-rails-编辑器支援七牛云存储/","excerpt":"wysiwyg-rails-qiniu 是基于 wysiwyg-rails制作, 上传的资源直接支持七牛云存储在使用该gem包前,你得会使用七牛云存储传送门: Rails 进阶—— 云存储实战","text":"wysiwyg-rails-qiniu 是基于 wysiwyg-rails制作, 上传的资源直接支持七牛云存储在使用该gem包前,你得会使用七牛云存储传送门: Rails 进阶—— 云存储实战 安装添加下面代码到你的 Gemfile: 1gem \"wysiwyg-rails-qiniu\" 然后运行 bundle install. 将资源文件加入到你的 assets目录在你的 application.css 文件中, 引入下列文件: 12345/* *= require froala_editor.min.css *= require froala_style.min.css *= require font-awesome */ 如果你想使用黑色主题, 你可以加入 themes/dark.min.css 到application.css文件中. 在你的 application.js, 引入以下文件: 123////= require froala_editor.min.js// 如果你想使用更多功能插件 Available Plugins, 你应该将下面的这些文件加入的 application.js 和 application.css.其中support_qiniu.min.js是必须要引入的,否则无法使用七牛云存储123456789101112131415161718192021222324252627// Include other plugins.//= require plugins/support_qiniu.min.js//= require plugins/align.min.js//= require plugins/char_counter.min.js//= require plugins/code_beautifier.min.js//= require plugins/code_view.min.js//= require plugins/colors.min.js//= require plugins/emoticons.min.js//= require plugins/entities.min.js//= require plugins/file.min.js//= require plugins/font_family.min.js//= require plugins/font_size.min.js//= require plugins/fullscreen.min.js//= require plugins/image.min.js//= require plugins/image_manager.min.js//= require plugins/inline_style.min.js//= require plugins/line_breaker.min.js//= require plugins/link.min.js//= require plugins/lists.min.js//= require plugins/paragraph_format.min.js//= require plugins/paragraph_style.min.js//= require plugins/quick_insert.min.js//= require plugins/quote.min.js//= require plugins/save.min.js//= require plugins/table.min.js//= require plugins/url.min.js//= require plugins/video.min.js 1234567891011121314/* *= require plugins/char_counter.min.css *= require plugins/code_view.min.css *= require plugins/colors.min.css *= require plugins/emoticons.min.css *= require plugins/file.min.css *= require plugins/fullscreen.min.css *= require plugins/image_manager.min.css *= require plugins/image.min.css *= require plugins/line_breaker.min.css *= require plugins/quick_insert.min.css *= require plugins/table.min.css *= require plugins/video.min.css */ 同样的,如果你要使用中文语言包,请加入响应的js 12// Include Language if needed//= require languages/zh_cn.js 到目前位置你已经配置好编辑的基本资源,你需要重启rails服务器 初始化编辑器详细文档请参见作者官网,提供了初始化代码 Froala WYSIWYG Editor official documentation. 这里提供部分示例代码, 在使用下面代码之前你应该需要知道如何生成七牛上传凭证123456789101112131415161718192021222324252627$(function() &#123; $('#edit').froalaEditor(&#123; language: \"zh_cn\", width: 900, heightMin: 300, heightMax: 500, requestWithCORS: false, //图片上传配置(必须) imageUploadDomain: \"&lt;%= Rails.application.config.qiniu_domain %&gt;\", //七牛云存储空间域名地址 imageUploadParam: 'file', imageUploadURL: 'http://upload.qiniu.com', //七牛上传服务器, 如果是海外服务器为 http://up.qiniu.com imageUploadParams: &#123; token: '&lt;%= @uptoken %&gt;'&#125;, //上传凭证, 详细规则查看七牛官方文档 imageUploadMethod: 'POST', imageMaxSize: 5 * 1024 * 1024, imageAllowedTypes: ['jpeg', 'jpg', 'png'], //文件上传配置(必须) fileUploadDomain: \"&lt;%= Rails.application.config.qiniu_domain %&gt;\", //七牛云存储空间域名地址 fileUploadParam: 'file', fileUploadURL: 'http://upload.qiniu.com', //同上 fileUploadParams: &#123; token: '&lt;%= @uptoken %&gt;'&#125;, //同上 fileUploadMethod: 'POST', fileMaxSize: 20 * 1024 * 1024, fileAllowedTypes: ['*'] &#125;);&#125;); 配置代码视图使用代码视图加高亮效果,可加入以下代码,也可以使用codemirror-rails这个gem包 123&lt;link href=\"//cdnjs.cloudflare.com/ajax/libs/codemirror/5.3.0/codemirror.min.css\" media=\"screen\" rel=\"stylesheet\"&gt;&lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/codemirror/5.3.0/codemirror.min.js\"&gt;&lt;/script&gt;&lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/codemirror/5.3.0/mode/xml/xml.min.js\"&gt;&lt;/script&gt; 许可wyg-rails项目是在麻省理工学院的许可。然而,为了使用Froala WYSIWYG HTML编辑器插件你应该购买一个许可证。下面是许可链接,请支持源作者Froala Editor has 3 different licenses.For details please see License Agreement. 致谢感谢Froala项目作者的贡献, 我在项目的原基础上增加了对七牛云存储的支持.如果你需要使用其它的云存储平台,请使用wysiwyg-rails进行自定义配置","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://tkvern.com/categories/Ruby-on-Rails/"}],"tags":[{"name":"七牛云存储","slug":"七牛云存储","permalink":"https://tkvern.com/tags/七牛云存储/"}],"keywords":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://tkvern.com/categories/Ruby-on-Rails/"}]},{"title":"七牛云存储使用教程(Ruby-on-Rails-+-JavaScript)","slug":"七牛云存储使用教程(Ruby-on-Rails-+-JavaScript)","date":"2016-02-18T13:26:49.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20160218/七牛云存储使用教程(Ruby-on-Rails-+-JavaScript)/","link":"","permalink":"https://tkvern.com/20160218/七牛云存储使用教程(Ruby-on-Rails-+-JavaScript)/","excerpt":"吐槽写教程之前不得不吐槽一下七牛的官方文档，API的说明是很全面，但是读起来超蛋疼。为什么这么说呢，按照我以往的看API的文档都会有示例代码跑起来帮助理解，而七牛的API文档对于刚接触这种第三方服务商SDK的开发者来说不是太友好。建议七牛借鉴下百度地图SDK的文档写法。","text":"吐槽写教程之前不得不吐槽一下七牛的官方文档，API的说明是很全面，但是读起来超蛋疼。为什么这么说呢，按照我以往的看API的文档都会有示例代码跑起来帮助理解，而七牛的API文档对于刚接触这种第三方服务商SDK的开发者来说不是太友好。建议七牛借鉴下百度地图SDK的文档写法。 初识七牛云存储是一家专注云存储领域的技术公司，提供云存储、云处理、云加速分发一站式服务，持续追求高可靠、高可用、高性能、高响应速度，推动客户健康稳定地快速发展。（前面是广告） 以往开发项目时总会遇到上传文件的问题，譬如上传速度、断点续传、资源服务器部署等等。存在自己的服务器上面，维护成本高。那如何解决这些问题呢，有需求就有市场，云存储应运而生，把这些处理统统放到云存储上，只需要进行API调用即可，而这次我们选中了七牛云存储，便宜，好用，快速。（广告打了一大堆，进入正题吧） 使用教程正式开始 注册使用前得先注册一个七牛云存储的账号，–&gt;注册传送门&lt;– 登录认证登录之后查看你的账号身份认证，完成认证解锁更多功能 获取AK, SK,空间域名这两个KEY值是用来生成上传凭证的 配置服务器环境在使用七牛云存储前我们先要配置好上传凭证的生成环境 代码清单3.6.1: 导入七牛云存储的gem包Gemfile12345678910111213source 'https://rubygems.org'# Bundle edge Rails instead: gem 'rails', github: 'rails/rails'gem 'rails', '~&gt;4.2.3'# Use postgresql as the database for Active Record...gem 'qiniu' #加入七牛云存储gem包... 代码清单3.6.2: 然后重新bundle我们的项目会看到安装了很多gem包 12345678910$ bundle install...Using qiniu 6.5.1...Bundle complete! 17 Gemfile dependencies, 66 gems now installed.Use `bundle show [gemname]` to see where a bundled gem is installed. 如果有提示安装失败或是无法安装一些国外的镜像可修改Gemfile的源到淘宝源或是自行翻墙，推荐一款翻墙工具Shadowsocks 配置AccessKey/SecretKey代码清单3.7.1: 新建qiniu_sdk.rb文件,将3.3节获取到的AK,SK,空间域名地址输入下面代码config/initializers/qiniu_sdk.rb12345678#!/usr/bin/env rubyrequire 'qiniu'Qiniu.establish_connection! :access_key =&gt; '&lt;输入你的AK&gt;', :secret_key =&gt; '&lt;输入你的SK&gt;'Rails.application.config.qiniu_domain = \"&lt;空间域名地址&gt;\" 生成上传凭证代码清单3.8.1: 这个方法我会包装到Helper里面app/helpers/application_helper.rb123456789101112131415module ApplicationHelper private def uptoken put_policy = Qiniu::Auth::PutPolicy.new( \"&lt;你的空间名称&gt;\", # 存储空间 nil, # 最终资源名，可省略，即缺省为“创建”语义 1800, # 相对有效期，可省略，缺省为3600秒后 uptoken 过期 (Time.now + 30.minutes).to_i # 绝对有效期，可省略，指明 uptoken 过期期限（绝对值），通常用于调试，这里表示半小时 ) uptoken = Qiniu::Auth.generate_uptoken(put_policy) #生成凭证 endend 到目前为止我们以及完成了服务端的所有配置,当我们的文件上传时,是不经过我们自己的服务器的,由客户端通过Ajax请求七牛的API再将返回的文件名存入我们的服务器。接下来就是客户端的配置 导入七牛JavaScriptSDK–&gt;下载JavaScriptSDK传送门&lt;– 代码清单3.9.1: 为了代码易于管理我们将七牛的JavaScriptSDK文件放到app/assets/javascripts/plugins目录 123456789101112131415- app - assets + fonts + images - javascript - plugins - plupload moxie.js plupload.dev.js plupload.full.min.js - qiniu qiniu.js qiniu.min.js application.js + stylesheets 代码清单3.9.2: 引用SDK到application.jsapp/assets/javascripts/application.js1234567// # Place all the behaviors and hooks related to the matching controller here.// # All this logic will automatically be available in application.js.// # You can use CoffeeScript in this file: http://coffeescript.org///= require plugins/plupload/moxie//= require plugins/plupload/plupload.dev//= require plugins/qiniu/qiniu 初始化javascript在完成以上操作之后我们就可以正式使用七牛云存储了 代码清单3.9.3: 在controller中引入helper方法，传入上传凭证app/controllers/uploads_controller.rb12345678class UploadsController &lt; ActionController::BaseController include ApplicationHelper def index # 获取上传凭证 @uptoken = uptoken endend 代码清单3.9.4: 代码清单在视图文件中使用app/views/upload/index.html.erb123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!-- 初始化按钮 start --&gt;&lt;div class=\"col-md-12\"&gt; &lt;div id=\"container\" style=\"position: absolute; top: 50px;\"&gt; &lt;a class=\"btn btn-default btn-lg \" id=\"pickfiles\" href=\"#\" style=\"position: relative; z-index: 1;\"&gt; &lt;i class=\"fa fa-plus\"&gt;&lt;/i&gt; &lt;span&gt;选择文件&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 初始化按钮 end --&gt;&lt;!-- 初始化配置 start --&gt;&lt;script type=\"text/javascript\"&gt; var uploader = Qiniu.uploader(&#123; runtimes: 'html5,html4', //上传模式,依次退化 browse_button: 'pickfiles', //上传选择的点选按钮，**必需** uptoken : '&lt;%= @uptoken %&gt;', //若未指定uptoken_url,则必须指定 uptoken ,uptoken由其他程序生成 unique_names: true, // 默认 false，key为文件名。若开启该选项，SDK会为每个文件自动生成key（文件名） save_key: true, // 默认 false。若在服务端生成uptoken的上传策略中指定了 `sava_key`，则开启，SDK在前端将不对key进行任何处理 domain: '&lt;%= Rails.application.config.qiniu_domain %&gt;', //bucket 域名，下载资源时用到，**必需** container: 'container', //上传区域DOM ID，默认是browser_button的父元素， max_file_size: '5mb', //最大文件体积限制 // flash_swf_url: 'js/plupload/Moxie.swf', //引入flash,相对路径 max_retries: 3, //上传失败最大重试次数 dragdrop: true, //开启可拖曳上传 drop_element: 'container', //拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传 chunk_size: '1mb', //分块上传时，每片的体积 auto_start: true, //选择文件后自动上传，若关闭需要自己绑定事件触发上传 init: &#123; 'FilesAdded': function(up, files) &#123; plupload.each(files, function(file) &#123; // 文件添加进队列后,处理相关的事情 &#125;); &#125;, 'BeforeUpload': function(up, file) &#123; // 每个文件上传前,处理相关的事情 &#125;, 'UploadProgress': function(up, file) &#123; // 每个文件上传时,处理相关的事情 &#125;, 'FileUploaded': function(up, file, info) &#123; // 每个文件上传成功后,处理相关的事情 // 其中 info 是文件上传成功后，服务端返回的json，形式如 // &#123; // \"hash\": \"Fh8xVqod2MQ1mocfI4S4KpRL6D98\", // \"key\": \"gogopher.jpg\" // &#125; // 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html var domain = up.getOption('domain'); var res = $.parseJSON(info); var sourceLink = domain + res.key; //获取上传成功后的文件的Url console.log(info); console.log(sourceLink); &#125;, 'Error': function(up, err, errTip) &#123; //上传出错时,处理相关的事情 &#125;, 'UploadComplete': function() &#123; //队列文件处理完毕后,处理相关的事情 &#125;, 'Key': function(up, file) &#123; // 若想在前端对每个文件的key进行个性化处理，可以配置该函数 // 该配置必须要在 unique_names: false , save_key: false 时才生效 var key = \"\"; // do something with key here return key &#125; &#125;&#125;);&lt;/script&gt;&lt;!-- 初始化配置 end --&gt; 代码清单3.9.5: 完成了这么多复杂的操作后终于可以试试效果了，启动Rails服务器看看吧1$ rails server -b $IP -p $PORT 作者如果教程里面有什么纰漏的地方请给我留言","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://tkvern.com/categories/Ruby-on-Rails/"}],"tags":[{"name":"七牛云存储","slug":"七牛云存储","permalink":"https://tkvern.com/tags/七牛云存储/"}],"keywords":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://tkvern.com/categories/Ruby-on-Rails/"}]},{"title":"Gulp构建实例","slug":"Gulp构建实例","date":"2015-12-10T13:26:49.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20151210/Gulp构建实例/","link":"","permalink":"https://tkvern.com/20151210/Gulp构建实例/","excerpt":"结构说明assets项目资源目录，dev开发目录，dist编译输出目录，gulpfile.js自动化工具API","text":"结构说明assets项目资源目录，dev开发目录，dist编译输出目录，gulpfile.js自动化工具API gulp的使用安装node环境(自行goole即可)全局安装gulp1$ npm install gulp -g 进入到需要gulp管理的项目路径, 如 /gulp 再安装一遍1$ npm install gulp --save-dev 安装gulp插件1$ npm install --save-dev gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del 1234567891011sass的编译 (`gulp-ruby-sass`)自动添加css前缀（`gulp-autoprefixer`）压缩css（`gulp-minify-css`）js代码校验（`gulp-jshint`）合并js文件（`gulp-concat`）压缩js代码（`gulp-uglify`）压缩图片（`gulp-imagemin`）自动刷新页面（`gulp-livereload`）图片缓存，只有图片替换了才压缩（`gulp-cache`）更改提醒（`gulp-notify`）清除文件（`del`） 5.运行task任务1$ gulp 监听文档实现实时编译 1$ gulp watch gulp的API请查看gulpfile.js文件scss文件规范以及说明各个小模块以下划线开头全小写命名多单词以 - 符号分隔，总模块正常，以该模块文件夹命名，在其中导入需要的小模块(详细规则请查看font-awesome的scss源码，更多内容google脑补)例：_path.scss路径配置文件，_mixins.scss预编译文件，_variables.scss变量定义文件，font-awesome.scss模块导入文件 脚本使用说明基本组件error.js用途：低版本浏览器访问限制用法：在head标签中最先引入下列代码123&lt;!--[if lt IE 9]&gt; &lt;script src=\"dist/js/error.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; mian.js用途：javascript入口文件负责渲染数据处理交互用法：引入即可，涉及模块较多后续完善模块说明 date.js用途：解析处理日期数据，支持多种日期格式用法：调用Date方法12345678910111213Date.today() // Returns today's date, with time set to 00:00 (start of day).Date.today().next().friday() // Returns the date of the next Friday.Date.today().last().monday() // Returns the date of the previous Monday.new Date().next().march() // Returns the date of the next March.new Date().last().week() // Returns the date one week ago. Date.today().is().friday() // Returns true|false if the day-of-week matches.Date.today().is().fri() // Abbreviated day names. Date.today().is().november() // Month names.Date.today().is().nov() // Abbreviated month names. daterange-picker.js用途：基于bootstrapt的日期范围选择器 modernizr.custom.js用途：提供过渡动画支持 jQuery组件jquery.bootstrap.wizard.js用途：基于jQuery的Bootstrap向导式插件 jquery.dataTables.js用途：表格处理插件，包括排序分页，宽度自动处理用法：引入后，以下结构绘制表格例：12345678910111213141516171819&lt;table class=\"table table-bordered\" id=\"dataTable1\"&gt; &lt;thead&gt; &lt;th class=\"check-header\"&gt; &lt;label&gt;&lt;input id=\"checkAll\" name=\"checkAll\" type=\"checkbox\"&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt; &lt;/th&gt; &lt;th&gt;字段1&lt;/th&gt; &lt;th&gt;字段2&lt;/th&gt; &lt;th&gt;字段3&lt;/th&gt; &lt;th&gt;字段4&lt;/th&gt; &lt;th&gt;字段5&lt;/th&gt; &lt;th&gt;字段6&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; ... ... ... &lt;/tbody&gt;&lt;/table&gt; 12345678910111213141516171819202122232425/* 根据ID初始化表格，以下 .table 类用于实现单选和多选*/$(\"#dataTable1\").dataTable(&#123; \"sPaginationType\": \"full_numbers\", aoColumnDefs: [ &#123; bSortable: false, aTargets: [0, -1] &#125; ]&#125;);$('.table').each(function() &#123; return $(\".table #checkAll\").click(function() &#123; if ($(\".table #checkAll\").is(\":checked\")) &#123; return $(\".table input[type=checkbox]\").each(function() &#123; return $(this).prop(\"checked\", true); &#125;); &#125; else &#123; return $(\".table input[type=checkbox]\").each(function() &#123; return $(this).prop(\"checked\", false); &#125;); &#125; &#125;);&#125;); jquery.easy-pie-chart.js用途：饼状图绘制工具用法：引入文件后，按ID初始化DOM元素传送门：rendro.github.io例：1234567891011121314151617181920212223242526&lt;!-- Donut Charts --&gt;&lt;div class=\"col-lg-8\"&gt;&lt;div class=\"widget-container\"&gt; &lt;div class=\"heading\"&gt; &lt;i class=\"fa fa-bar-chart\"&gt;&lt;/i&gt; 优惠券使用率 &lt;/div&gt; &lt;div class=\"widget-content clearfix\"&gt; &lt;div class=\"col-sm-4\"&gt; &lt;div class=\"pie-chart1 pie-chart pie-number easyPieChart\" data-percent=\"60\" style=\"width: 200px; height: 200px; line-height: 200px;\"&gt; 60% &lt;canvas width=\"200\" height=\"200\"&gt;&lt;/canvas&gt;&lt;p class=\"h6\"&gt;总使用率&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-sm-4\"&gt; &lt;div class=\"pie-chart2 pie-chart pie-number easyPieChart\" data-percent=\"86\" style=\"width: 200px; height: 200px; line-height: 200px;\"&gt; 86% &lt;canvas width=\"200\" height=\"200\"&gt;&lt;/canvas&gt;&lt;p class=\"h6\"&gt;代金券使用率&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-sm-4\"&gt; &lt;div class=\"pie-chart3 pie-chart pie-number easyPieChart\" data-percent=\"34\" style=\"width: 200px; height: 200px; line-height: 200px;\"&gt; 34% &lt;canvas width=\"200\" height=\"200\"&gt;&lt;/canvas&gt;&lt;p class=\"h6\"&gt;折扣券使用率&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- end Donut Charts --&gt; 12345678910111213141516171819202122232425262728293031323334353637383940/*# =============================================================================# Easy Pie Chart# =============================================================================*//* &gt;60% #81e970 green &gt;=30% &amp; &lt;=60% #fab43b yellow &lt;30% #f46f50 red size 图型大小 lineWidth 线宽 lineCap 线类型 barColor 线颜色 animate 动画速度 scaleColor 选择色*/$(\".pie-chart1\").easyPieChart(&#123; size: 200, lineWidth: 12, lineCap: \"square\", barColor: \"#81e970\", animate: 800, scaleColor: false&#125;);$(\".pie-chart2\").easyPieChart(&#123; size: 200, lineWidth: 12, lineCap: \"square\", barColor: \"#81e970\", animate: 800, scaleColor: false&#125;);$(\".pie-chart3\").easyPieChart(&#123; size: 200, lineWidth: 12, lineCap: \"square\", barColor: \"#f46f50\", animate: 800, scaleColor: false&#125;); jquery.sparkline.js用途：canvas图表绘制工具用法：引入后按ID初始化，ul部分为横轴坐标，可在style.scss文件中配置宽度传送门：omnipotent.net例：12345678910111213141516171819202122232425262728293031&lt;div class=\"widget-container\"&gt; &lt;div class=\"heading\"&gt; &lt;i class=\"fa fa-area-chart\"&gt;&lt;/i&gt; 日活跃用户 &lt;/div&gt; &lt;div class=\"widget-content padded\"&gt; &lt;div class=\"chart-graph line-chart\"&gt; &lt;div id=\"linechart-2-1\"&gt;&lt;canvas width=\"619\" height=\"226\" style=\"display: inline-block; width: 619px; height: 226px; vertical-align: top;\"&gt;&lt;/canvas&gt;&lt;/div&gt; &lt;ul class=\"chart-text-axis day\"&gt; &lt;li&gt; 1 &lt;/li&gt; &lt;li&gt; 5 &lt;/li&gt; &lt;li&gt; 10 &lt;/li&gt; &lt;li&gt; 15 &lt;/li&gt; &lt;li&gt; 20 &lt;/li&gt; &lt;li&gt; 25 &lt;/li&gt; &lt;/ul&gt; &lt;!-- end Line Chart --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839(function() &#123; var linechartResize; /* $(id).sparkline([number1, number2， ... ...],&#123; options &#125;) type: 线类型 width: 宽度 height: 高度 lineColor: 线颜色 fillColor: 填充色 lineWidth: 线宽 spotColor: 点色 minSpotColor: 最小点色 maxSpotColor: 最大点色 highlightSpotColor: 高亮点色 highlightLineColor: 高亮线色 spotRadius: 点半径 chartRangeMin: 图最小范围 */ linechartResize = function() &#123; $(\"#linechart-1\").sparkline([160, 240, 120, 200, 230, 180, 350, 230, 200, 280, 380, 400, 360, 300, 220, 200, 150, 40, 70, 180, 110,200, 160, 200, 220, 350, 230, 200, 280, 380, 70], &#123; type: \"line\", width: \"100%\", height: \"226\", lineColor: \"#a5e1ff\", fillColor: \"rgba(241, 251, 255, 0.9)\", lineWidth: 2, spotColor: \"#a5e1ff\", minSpotColor: \"#bee3f6\", maxSpotColor: \"#a5e1ff\", highlightSpotColor: \"#80cff4\", highlightLineColor: \"#cccccc\", spotRadius: 6, chartRangeMin: 0 &#125;);&#125;) jquery.validate.js用途：表单验证插件用法：添加DOM元素自定义属性(具体内容见官方API)传送门：jqueryvalidation.org例:1234567891011121314151617(1)required:true 必输字段(2)remote:\"check.php\" 使用ajax方法调用check.php验证输入值(3)email:true 必须输入正确格式的电子邮件(4)url:true 必须输入正确格式的网址(5)date:true 必须输入正确格式的日期(6)dateISO:true 必须输入正确格式的日期(ISO)，例如：2009-06-23，1998/01/22 只验证格式，不验证有效性(7)number:true 必须输入合法的数字(负数，小数)(8)digits:true 必须输入整数(9)creditcard: 必须输入合法的信用卡号(10)equalTo:\"#field\" 输入值必须和#field相同(11)accept: 输入拥有合法后缀名的字符串（上传文件的后缀）(12)maxlength:5 输入长度最多是5的字符串(汉字算一个字符)(13)minlength:10 输入长度最小是10的字符串(汉字算一个字符)(14)rangelength:[5,10] 输入长度必须介于 5 和 10 之间的字符串\")(汉字算一个字符)(15)range:[5,10] 输入值必须介于 5 和 10 之间(16)max:5 输入值不能大于5(17)min:10 输入值不能小于10","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}],"tags":[{"name":"Gulp","slug":"Gulp","permalink":"https://tkvern.com/tags/Gulp/"}],"keywords":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}]},{"title":"基于原生JS移动端响应式解决方案——AUTOSTRAP","slug":"autostrap","date":"2015-08-19T14:41:14.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20150819/autostrap/","link":"","permalink":"https://tkvern.com/20150819/autostrap/","excerpt":"介绍就目前移动端而言，已有比较成熟都响应式框架，类似于Bootstrap、AmazeUI、Skeljs。但是对于普通开发者来说，为了满足快速开发的需求去学习和使用这些框架的时间成本是比较高的。所以，本着轻量、快速开发的原则，为大家提供了基于原生JS的移动动端解决方案，希望能在交流、使用中继续优化AutoStrap。","text":"介绍就目前移动端而言，已有比较成熟都响应式框架，类似于Bootstrap、AmazeUI、Skeljs。但是对于普通开发者来说，为了满足快速开发的需求去学习和使用这些框架的时间成本是比较高的。所以，本着轻量、快速开发的原则，为大家提供了基于原生JS的移动动端解决方案，希望能在交流、使用中继续优化AutoStrap。 原理目前我们熟悉的开源前端框架都是栅格化布局，通过mediaQuery，在不同分辨率加载不同的css达到响应式的效果。同时还提供了诸多的JS组件供开发者使用。而AutoStrap是使用viewport，以iPhone4分辨率为模板，根据可视宽高调节缩放比例实现。具体内容下面的代码会给出。 代码autostrap.js1234567891011121314151617181920212223242526272829/*! * AutoStrap v1.0.0 (http://largesoft.org) * Copyright 2015 Vern, Inc. */var g = document.documentElement.clientWidth, h = document.documentElement.clientHeight, clientWidth = document.documentElement.clientWidth, viewport = document.getElementById(\"MobileViewport\");function isWeixin() &#123; var a = navigator.userAgent.toLowerCase(); return \"micromessenger\" == a.match(/MicroMessenger/i) ? !0 : !1&#125;function renderPage() &#123; var f = 1; g / h &gt;= 320 / 486 ? (f = g / 486) : (f = g / 320); if(g == 320)&#123; f = 1; &#125; viewport.content = \"width=320, initial-scale=\" + f + \", maximum-scale=\" + f + \", user-scalable=no\"; if (320 != clientWidth &amp;&amp; clientWidth == document.documentElement.clientWidth || isWeixin() &amp;&amp; (navigator.userAgent.indexOf(\"Android\") &gt; -1 || navigator.userAgent.indexOf(\"Linux\") &gt; -1)) &#123; var i = 320 / g, j = 486 / h, k = Math.max(i, j); k = k &gt; 1 ? k : 160 * k, k = parseInt(k), viewport.content= \"width=320, target-densitydpi=\" + k ; &#125;&#125;renderPage(); autostrap.css1234567891011121314151617181920212223242526272829303132333435363738394041/*! * AutoStrap v1.0.0 (http://largesoft.org) * Copyright 2015 Vern, Inc. */html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, font, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td &#123; margin: 0; padding: 0; border: 0; outline: 0; font-size: 100%; vertical-align: baseline; background: transparent;&#125;body &#123;line-height: 1; background-color: rgba(233,233,231,1);&#125;body *&#123; max-width: 320px!important; font-family: \"microsoft yahei\";&#125;ol, ul &#123;list-style: none;&#125;blockquote, q &#123;quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123;content: '';content: none;&#125;/* remember to define focus styles! */:focus &#123;outline: 0;&#125;/* remember to highlight inserts somehow! */ins &#123;text-decoration: none;&#125;del &#123;text-decoration: line-through;&#125;/* tables still need 'cellspacing=\"0\"' in the markup */table &#123;border-collapse: collapse;border-spacing: 0;&#125;hr&#123;margin-top: 5px;margin-bottom: 5px;border: 0;border-top: 1px dashed #eee;&#125; html页面引入代码1&lt;meta id=\"MobileViewport\" name=\"viewport\" content=\"width=320, initial-scale=1, maximum-scale=1, user-scalable=no\" servergenerated=\"true\"&gt; 使用1、页面引入autostrap.js、autostrap.css文件2、在标签里面加入以下代码1&lt;meta id=”MobileViewport” name=”viewport” content=”width=320, initial-scale=1, maximum-scale=1, user-scalable=no” servergenerated=”true”&gt; 规范标签内都所以元素都大小不超过320px即可，如果有特殊动画超过320px，将body的overflow属性设为hidden即可 下载个人博客传送门：largesoft.org(老博客地址已失效，请前往https://github.com/tkvern)","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}],"tags":[{"name":"autostrap","slug":"autostrap","permalink":"https://tkvern.com/tags/autostrap/"}],"keywords":[{"name":"Front-end","slug":"Front-end","permalink":"https://tkvern.com/categories/Front-end/"}]},{"title":"清晨风・岳麓北","slug":"清晨风岳麓北","date":"2014-04-26T02:00:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20140426/清晨风岳麓北/","link":"","permalink":"https://tkvern.com/20140426/清晨风岳麓北/","excerpt":"雨雾天气登上岳麓山顶，忆容若，《长相思》，作此诗于长沙，2014-04-26 10:00 笔","text":"雨雾天气登上岳麓山顶，忆容若，《长相思》，作此诗于长沙，2014-04-26 10:00 笔 清晨风・岳麓北张翔风一程雨一程小街未晴又一程花蝴蝶白蝴蝶醉若汝生迷蝴蝶宵漏青灰玉笛云云许是容若半生缘","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"淡淡的","slug":"淡淡的","date":"2013-03-01T22:57:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20130301/淡淡的/","link":"","permalink":"https://tkvern.com/20130301/淡淡的/","excerpt":"我们，简简单单，静静的、淡淡的就好，作于永州，2013-03-02 06:57 笔","text":"我们，简简单单，静静的、淡淡的就好，作于永州，2013-03-02 06:57 笔 淡淡的张翔淡淡的花香飘过我身旁在这美丽的夜晚星空多么明亮照亮了你的脸庞淡淡的洒下一点点月光落在了浅浅河床披上银色衣装像是出嫁的新娘淡淡的琴声在悠悠飘扬不小心撞进心房激起小小波澜我时刻在为你牵绊我的爱 淡淡的微微笑着 听你歌唱心意我都知道你不说我都明了爱着你 淡淡的细细听着 甜蜜味道我全部都尝到我这样爱你就好淡淡的花香飘过我身旁在这美丽的夜晚星空多么明亮照亮了你的脸庞淡淡的洒下一点点月光落在了浅浅河床披上银色衣装像是出嫁的新娘淡淡的琴声在悠悠飘扬不小心撞进心房激起小小波澜我时刻在为你牵绊我的爱 淡淡的微微笑着 听你歌唱心意我都知道你不说我都明了爱着你 淡淡的细细听着 甜蜜味道我全部都尝到我这样爱你就好平平淡淡才最重要和你相伴到老","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"雨夜","slug":"雨夜","date":"2012-07-25T11:41:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120725/雨夜/","link":"","permalink":"https://tkvern.com/20120725/雨夜/","excerpt":"雨夜，独行，作于永州，2012-07-25 19:41 笔","text":"雨夜，独行，作于永州，2012-07-25 19:41 笔 雨夜张翔天要下雨了你在哪里呢这夜好静 好静只听得到雨的声音滴答 滴答雨 停了云 散了我却还撑着伞想把着雨夜留下等你一起漫步","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"怀念","slug":"怀念","date":"2012-06-18T16:03:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120618/怀念/","link":"","permalink":"https://tkvern.com/20120618/怀念/","excerpt":"《怀念》带着怀念，在静静怀念，作于永州，2012-06-19 00:03 笔","text":"《怀念》带着怀念，在静静怀念，作于永州，2012-06-19 00:03 笔 怀念张翔时间冲淡你笑的画面我用笔尖轻轻去怀念绿茶带着苦涩的咸你忘记了香芋的甜我赶在落幕之前再看看你的身影思念又在悄悄的蔓延我抚摸你泛黄的相片怎么也想不起你在身边我只是在怀念是不是再也找不回起点你已经远去我还站在原地天空飘起小雨沉默对着结局微笑着眼泪掩饰了情绪视线变得模糊你消失在远处散不去的浓雾怎么没有弥补只是我爱得太过仓促 旁白(爱，是不是太过仓促，才会措手不及。可是，时间却会冲淡一切，渐渐地也抚平或是忘记了留下的痕迹。来过吗？问自己，或许时间已经把记忆删除了。每一首词，都有她背后的故事，有故事，便有人物，谁都可以是主角，谁都也不是主角，里面是词的情感披露，也是叹息……）","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"酒馆","slug":"酒馆","date":"2012-06-05T00:42:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120605/酒馆/","link":"","permalink":"https://tkvern.com/20120605/酒馆/","excerpt":"酒馆，少了点什么，作于永州，2012-06-05 08:42 笔","text":"酒馆，少了点什么，作于永州，2012-06-05 08:42 笔 酒馆张翔良驹惹谁 奔受千里累束谏急飞 宫门玉殿追驿下小歇 折影身半垂暮色倾颓 玉箫夜歌谁还见带雁南飞柳绿春花盼你归香字成灰轻风吹我在酒馆等你几时归昨夜酌酒你不回半倚门扉小酒浅醉细雨遮梅你笑在朦胧中更美 （写到这里，有些思绪远了，只好停笔下来）","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"夜醉了","slug":"夜醉了","date":"2012-06-03T19:38:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120603/夜醉了/","link":"","permalink":"https://tkvern.com/20120603/夜醉了/","excerpt":"夜醉了，作于永州，2012-06-04 03:38 笔","text":"夜醉了，作于永州，2012-06-04 03:38 笔 夜醉了张翔夜深了 酒醒了亲爱的 你好吗夜静了 梦醒了亲爱的 想你了怎么说不出口快要忘记了怎么留不下来快要离开了月色被掩盖了时间被冲淡了你的脸 变得模糊了熟悉的 也要陌生了该不该放手夜 醉了该不该放手要走了该不该放手夜 醉了该不该放手你走了一个人的日子平淡了平平淡淡冷冷清清就这样夜 醉了","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"再见了","slug":"再见了","date":"2012-05-31T14:43:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120531/再见了/","link":"","permalink":"https://tkvern.com/20120531/再见了/","excerpt":"再见，真的说了再见了，作于永州，2012-05-31 22:43 笔","text":"再见，真的说了再见了，作于永州，2012-05-31 22:43 笔 再见了张翔说好的约定都已经不见你消失在人群中间天空飘起了雨点看不清你的脸在某个路口擦肩听到你熟悉的声音怎么了已经说过再见了怎么了你已不在身边了都说了 忘了吧别让思念再蔓延了因为已经说再见了相信是谎言说好不留恋我停在你微笑瞬间翻出了陈旧信笺没有结局出现渐渐模糊的双眼只剩下街口的路灯怎么了已经说过再见了怎么了你已不在身边了都说了 忘了吧别让思念再蔓延了因为已经说再见了","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"春夏秋冬","slug":"春夏秋冬","date":"2012-04-22T15:24:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120422/春夏秋冬/","link":"","permalink":"https://tkvern.com/20120422/春夏秋冬/","excerpt":"一点点感悟，春夏秋冬，作此诗于永州，2012-04-22 23:24 笔","text":"一点点感悟，春夏秋冬，作此诗于永州，2012-04-22 23:24 笔 春夏秋冬张翔春风又作多情计夏雨滂沱无情地秋霜凉意不遮愁冬雪怎奈梅花意","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"无力","slug":"无力","date":"2012-04-22T06:58:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120422/无力/","link":"","permalink":"https://tkvern.com/20120422/无力/","excerpt":"瞎写的一些文字，作于永州，2012-04-22 14:58 笔","text":"瞎写的一些文字，作于永州，2012-04-22 14:58 笔 无力张翔挥舞着铅笔画不出思绪嘈杂的空气让人想发脾气有太多复杂问题快要抓破头皮真的呆不下去生活 生活 太多压力大到让人承受不起回到家里 Drink Coffee也变得空虚Sleep 在沙发里生活 生活 没钱没力女朋友也被人泡去都怪自己 No Money无能为力以后别跟钱过不去脱掉了外衣Swimming 的自己自由像只 Fish分不清东西对世界无所畏惧怎么能逃离失去氧气快要窒息生活 生活 太多压力大到让人承受不起回到家里 Drink Coffee也变得空虚Sleep 在沙发里生活 生活 没钱没力女朋友也被人泡去都怪自己 No Money无能为力以后别跟钱过不去","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"声声慢・初春","slug":"声声慢初春","date":"2012-04-17T09:12:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120417/声声慢初春/","link":"","permalink":"https://tkvern.com/20120417/声声慢初春/","excerpt":"循李清照之词《声声慢·寻寻觅觅》，写初春，诗。情在心间，作此诗于永州，2012-04-17 17:12 笔","text":"循李清照之词《声声慢·寻寻觅觅》，写初春，诗。情在心间，作此诗于永州，2012-04-17 17:12 笔 声声慢・初春张翔寻寻觅觅冷冷清清凄凄惨惨戚戚春暖寒冬初透凉风吹袖三杯两盏淡酒怎解愁醉意正浓余去也叹心头却是无泪相流翻教罗裙酒污奏一曲如今有谁听出入风随俗独自怎墨尺牍垂雨更泛轻舟到淇径缠缠绵绵此一生怎一个情字了得","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"无标题","slug":"无标题","date":"2012-04-15T02:30:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120415/无标题/","link":"","permalink":"https://tkvern.com/20120415/无标题/","excerpt":"用《无标题》来诠释。爱已走远，作于永州，2012-04-15 10:30 笔","text":"用《无标题》来诠释。爱已走远，作于永州，2012-04-15 10:30 笔 无标题张翔总是学不会又在夜里独自喝醉从脸颊划过的泪水匆匆带走了心碎没有思念的谁在枕着黑夜静静入睡爱成了累赘彼此相遇变得狼狈雨点在无力的下坠沉默着无以言对忘记了谁的谁也是否已经安然入睡没有标题没有回忆没有你留下的笔记在没有标题的世界里找不出来过的痕迹换了标题擦了回忆写了还熟悉的字体再看着平行的空间里时间斑驳了爱的足迹临摹的铅笔再也没有爱的标题","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"咖啡色","slug":"咖啡色","date":"2012-03-04T03:13:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120304/咖啡色/","link":"","permalink":"https://tkvern.com/20120304/咖啡色/","excerpt":"情侣。。对唱，作于永州，2012-03-04 11:13 笔","text":"情侣。。对唱，作于永州，2012-03-04 11:13 笔 咖啡色张翔男:咖啡的气息还是热的带着泥土颜色你说着味道苦涩不知道尝过后会是甜的女:奶茶是草莓加糖泡的染成粉红颜色你说甜了不好喝要知道甜的前面是苦的男:我们就这样沉默着（女:没什么说的）无言的对峙（女:被时间留滞）可不可以让我再说一次女:你说的话语无伦次（男:分不清主次）淡漠了文字（男:不过是说辞）你却平静说了真的没事合:怀念你（我）喜欢的咖啡色恋旧的方式有点独特女:爱走了男:梦醒了说分开是很容易的除了伤痛还会是什么结果呢怀念你（我）喜欢的粉红色微笑着都是健忘快乐男:怎么了女:要散了相处并不是简单的爱到最后只能是彼此都忘了 (作者：这里讲述的是一对情侣在咖啡厅分手都故事，两人的故事，伴随着咖啡的热气散去而慢慢结束，就像明知道结局是咖啡的味道一样。这是世界本身就是一个巨大的矛盾体。奶茶的香甜，是在经历咖啡的苦涩才体现出来的，而咖啡苦涩，在细细品味之后又格外的香甜，这证明“世界本身就是个巨大的矛盾体”因为咖啡和奶茶本身就是个存在地矛盾体……这是在咖啡厅里找到的灵感，因为刚好遇到这件事发生在身边，所以觉得有写一点东西的必要。)","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"天使折翼了","slug":"天使折翼了","date":"2012-03-01T06:52:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120301/天使折翼了/","link":"","permalink":"https://tkvern.com/20120301/天使折翼了/","excerpt":"练习。。《天使，折翼了》，作于永州，2012-03-01 14:52 笔","text":"练习。。《天使，折翼了》，作于永州，2012-03-01 14:52 笔 天使折翼了张翔你说你不懂我的冷漠伪装起来 不想让你选择太多我自言自语从不嫌罗嗦那些片段 一直藏在某个角落梦远了 爱淡淡的你走了 我独自失落爱的画面 我又翻了好几遍伤心却是多几分我望着你离去的身影要到哪里去找寻明天爱的画面 我又翻了好几遍笑容却是短暂间我哭着在拐角等你出现爱在那瞬间变成了永恒天使是不是也会承诺该说什么 我还是保持缄默你划过天空是否又错过灰白情节 我选择不再逃脱折翼了 泪水淹没等着天使再次降落爱的画面 我又翻了好几遍伤心却是多几分我望着你离去的身影要到哪里去找寻明天爱的画面 我又翻了好几遍笑容却是短暂间我哭着在拐角等你出现爱在那瞬间变成了永恒 注释罗同啰","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"简单就好","slug":"简单就好","date":"2012-03-01T06:52:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120301/简单就好/","link":"","permalink":"https://tkvern.com/20120301/简单就好/","excerpt":"练习曲，作于永州，2012-03-01 14:52 笔","text":"练习曲，作于永州，2012-03-01 14:52 笔 简单就好张翔我唱着老调的歌曲回到了非常古老的地方在哪里 鸟语花香你随着歌声进入梦乡我写着浪漫的歌曲迎着风 飘来阵阵花香细数着 樱花满天你紧紧地贴在我胸膛我明白这路还很长可是有你相依相伴珍重平平淡淡我只想要 爱简单就好多一点关怀少一分烦恼某个午后 有我陪伴着你不会感觉无聊我只想要 爱简单就好多一份温暖少一次寒潮晴朗阳光 你靠在我肩膀让我们慢慢变老","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"怎么能放下","slug":"怎么能放下","date":"2012-02-27T12:12:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120227/怎么能放下/","link":"","permalink":"https://tkvern.com/20120227/怎么能放下/","excerpt":"放下三部曲，《怎么能放下》最后一部了，作于永州，2012-02-27 20:12 笔","text":"放下三部曲，《怎么能放下》最后一部了，作于永州，2012-02-27 20:12 笔 怎么能放下张翔你的歌曲编乱了忘记写时刻我想起和你的粉蓝色又哭着笑了钢琴是谁在弹着还是温热的你的琴谱还没完成呢不要忘记了信笺留着 藏着书本里翻到了你说的 甜的 暖的我都记着在一起的快乐是你用音乐播放着说什么 没事了都是骗自己的等待着 回忆着怎么能 放下呢微笑着 泪流着放不下 述说着约定的幸福快乐很难割舍只是回忆的一直那么深刻要怎么忘记呢你冷了 孤单了守护的 是我呢清楚了 明白了放不下 是真的约定的幸福快乐很难割舍只是回忆的一直那么深刻又怎么能忘记呢 （歌写到这里，放下三部曲写完了。第一部放不下，很难割舍，经历太多太多，这是一段很值得守护，却没有好好珍惜的情感，最后错过了。因为太深刻，所以难以放下。第二部放下，很无奈，不得不放下，选择放下或许会带来更多快乐，所以骗着自己，说着明知道会被拆穿的谎，哭着笑着，真的找不回来了。第三部怎么能放下呢，这一部才成熟，才领悟，才在转角回过头来。）","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"放下","slug":"放下","date":"2012-02-27T02:15:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120227/放下/","link":"","permalink":"https://tkvern.com/20120227/放下/","excerpt":"放下三部曲之第二部《放下》，作于永州，2012-02-27 10:15 笔","text":"放下三部曲之第二部《放下》，作于永州，2012-02-27 10:15 笔 放下张翔天使的泪光擦过肩膀短暂的时光选择相伴可能我孤单还不会疗伤才让 自己很难忘飞过的天空留下坚强我一定还要继续飞翔我还在承诺何况那算什么谎就算错过也不怕遗憾我学会放手 放下你才走我说过的爱一个人就不要开口让自己放手所有美好回忆都保留爱到这里我就已足够我好久没写这些诗篇没想到笔墨不如从前回味我身旁闻得到你的发香这样一想是有些浪漫我学会放手 放下你才走你知道的在下个路口我还会回头让自己放手所有美好回忆都保留爱到这里我就已足够我就这样放下你才走","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"在这里","slug":"在这里","date":"2012-02-26T10:30:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120226/在这里/","link":"","permalink":"https://tkvern.com/20120226/在这里/","excerpt":"在这里，作于永州，2012-2-26 18:30 笔","text":"在这里，作于永州，2012-2-26 18:30 笔 在这里张翔写的歌总会带着回忆作着词总会想到别离好多画面 慢慢回忆好多相聚 变成别离遇见你我才有了生气爱上你才相信有奇迹照顾着你 怕会生气和我一起 发现奇迹或许拥有 才不会失去或许入迷 才不会出局同样的天气我在等着你或许经历 才懂得珍惜或许这里 不会有结局不一样的情绪我同样爱着这里","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"笔意书情","slug":"笔意书情","date":"2012-02-26T07:35:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120226/笔意书情/","link":"","permalink":"https://tkvern.com/20120226/笔意书情/","excerpt":"笔意书情（初稿），作于永州","text":"笔意书情（初稿），作于永州 笔意书情张翔三月春雨江南雨巷等你等南桥老树芽稀朦胧中尚许几丝婉离飞雁北去寒引菊香一季数落木萧瑟无迹暮色里秋雨空结愁绪携手你春秋湖心亭对弈看你回眸笑意不觉有些痴迷心神牵絆为你执子手相依识月下仙侣与诗文共赏析自抚木琴声余我再次提笔为你三月春雨江南雨巷等你等南桥老树芽稀朦胧中尚许几丝婉离飞雁北去寒引菊香一季数落木萧瑟无迹暮色里秋雨空结愁绪携手你春秋湖心亭对弈看你回眸笑意不觉有些痴迷心神牵絆为你执子手相依识月下仙侣与诗文共赏析自抚木琴声余我再次提笔为你","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"自弹一曲","slug":"自弹一曲","date":"2012-02-26T03:01:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120226/自弹一曲/","link":"","permalink":"https://tkvern.com/20120226/自弹一曲/","excerpt":"自弹一曲，作于永州","text":"自弹一曲，作于永州 自弹一曲张翔我切断与世界的所有联系躲在某个角落里偷偷的哭泣泪水掩盖了痕迹却掩盖不了那失声哭啼我逃离的身影是多么无力而你却自弹一曲透露出忧郁让我舍不得离去却又不得不让自己别离我告诉自己 要学会珍惜是非对错 要的结果并不是唯一我告诉自己 要学会放弃爱与不爱 你给的温柔我藏在心底你坚强的外表很值得怀疑脆弱才是你自己我再弹奏一曲引出你万千思绪我告诉自己 要学会珍惜是非对错 要的结果并不是唯一我告诉自己 要学会放弃爱与不爱 你给的温柔我藏在心底","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"餐厅","slug":"餐厅","date":"2012-02-25T08:51:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120225/餐厅/","link":"","permalink":"https://tkvern.com/20120225/餐厅/","excerpt":"餐厅，作于永州","text":"餐厅，作于永州 餐厅张翔我又经过这家餐厅角落里的对话翻译了好几遍你还是没有听清可能 只是有点怀恋还记得你坐在对面那饥饿的样子有点楚楚可怜我看着很是心疼你说 不喜欢那么甜我把它写在手心某一天还会出现不想懂得太多只怕会错过只怕会难过只怕还会泪光闪烁却没有一个依托不想失去太多只怕会堕落只怕会冷漠只怕还会再受折磨爱你的阻碍太多来不及跟你述说我只好匆匆走过你吃不完的那碗面我不愿意留剩全填在心里面明知道是会吃撑而我 却从没有敷衍陪你微笑的昨天某一天还会出现不想懂得太多只怕会错过只怕会难过只怕还会泪光闪烁却没有一个依托不想失去太多只怕会堕落只怕会冷漠只怕还会再受折磨爱你的阻碍太多来不及跟你述说我只好匆匆走过","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"琴键的温度","slug":"琴键的温度","date":"2012-01-23T03:21:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120123/琴键的温度/","link":"","permalink":"https://tkvern.com/20120123/琴键的温度/","excerpt":"琴键的温度，作于永州","text":"琴键的温度，作于永州 琴键的温度张翔不知道什么时候开始你搭上了钢琴的音轨音乐殿堂之上我遇见了安静的你不知道什么时候开始我爱上了跳动的音符琴弦低声吟唱你带着我的牵绊用心倾听我可以听到你所想用心感受我可以体会你心情多么希望让时间停在此刻有我的爱让掌心温度恒在忘了是什么时候开始破旧的钢琴看不见你琴房书架之上又见那岑寂的乐谱忘了是什么时候开始弹过的琴键还有温度打开记忆乐谱弹奏出你的音符用心倾听我可以听到你所想用心感受我可以体会你心情多么希望让时间停在此刻有我的爱让掌心温度恒在","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"梦回缘断","slug":"梦回缘断","date":"2012-01-23T03:19:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120123/梦回缘断/","link":"","permalink":"https://tkvern.com/20120123/梦回缘断/","excerpt":"梦回缘断(初稿)，作于永州","text":"梦回缘断(初稿)，作于永州 梦回缘断张翔长剑下只留沧桑疲倦还有所期盼漂泊天涯的路上孤独还有谁相伴那些年少的过往伤怀也无所羁绊离去的人在何方掌中结玉寄愁肠当仗剑走天涯我已无所牵挂刀光剑影之下血泪不住流淌染尽三尺百灵仍飘传一曲离殇当执杯醉看花落红入泥余香隐世山林无争笑叹世间繁华今生梦回缘断你问我是否能还长剑下只留沧桑疲倦还有所期盼漂泊天涯的路上孤独还有谁相伴那些年少的过往伤怀也无所羁绊离去的人在何方掌中结玉寄愁肠当仗剑走天涯我已无所牵挂刀光剑影之下血泪不住流淌染尽三尺百灵仍飘传一曲离殇当执杯醉看花落红入泥余香隐世山林无争笑叹世间繁华今生梦回缘断我欠你太多难还","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"一首简单的歌","slug":"一首简单的歌","date":"2012-01-23T03:17:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120123/一首简单的歌/","link":"","permalink":"https://tkvern.com/20120123/一首简单的歌/","excerpt":"一首简单的歌，作于永州","text":"一首简单的歌，作于永州 一首简单的歌张翔这个世界那么大我有太多的牵挂来到这里那么好是你让我忘不了我还不会说情话只是为你弹吉他啦啦 啦啦 啦啦我胡乱唱着这首歌只想你能听到哒哒 哒哒 哒哒我踩着零乱的步伐樱花在风中飘洒","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"写给你","slug":"写给你","date":"2012-01-23T03:15:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120123/写给你/","link":"","permalink":"https://tkvern.com/20120123/写给你/","excerpt":"写给你，作于永州","text":"写给你，作于永州 写给你张翔我已不想掩饰下去我知道我骗不了自己即使在梦里看到的还是你对你没有花言巧语我知道伪装不能继续让我告诉你从相识那天起你的可爱早就让我着迷每个夜里我都在想你我的诗只写给你我已控制不住爱上你一天看不到你我就会着急弹吉它都没有了旋律我的歌只唱给你才发现已经离不开你","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"我做不到","slug":"我做不到","date":"2012-01-23T03:13:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120123/我做不到/","link":"","permalink":"https://tkvern.com/20120123/我做不到/","excerpt":"我做不到，作于永州","text":"我做不到，作于永州 我做不到张翔人来人往的街道多少人擦肩而过我却回头看着你刚分手的你站在角落里没有哭泣我把安慰的话说给你时间匆匆的流逝我和你走到一起我用心保护着你忽然有一天我的冲动伤害在你心里我的挽留不希望离开你你让我别对你以前那么好可是我不明了我把错误一遍一遍检讨人群中把你四处寻找你让我别对你以前那么好可是我做不到我把歌谣在你耳边萦绕渴望回到从前那么好","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"视线","slug":"视线","date":"2012-01-23T03:10:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120123/视线/","link":"","permalink":"https://tkvern.com/20120123/视线/","excerpt":"视线，作于永州","text":"视线，作于永州 视线张 翔你不知道我的难过你也忘里对我的承诺黑色夜空下星星闪烁你问我它在等待什么当流星划过的时候你说再也不会离开我粉色信笺在风中飘落你说你不想再说太多我回忆开始的起点熟悉的地方有浮现陌生的茶香 还有芬芳我尝试着 改变结局你转身离去的身影我已看不清你的脸灰色的天空 灰色的眼你消逝在我视线里面","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"来不及说爱你","slug":"来不及说爱你","date":"2012-01-23T03:08:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120123/来不及说爱你/","link":"","permalink":"https://tkvern.com/20120123/来不及说爱你/","excerpt":"来不及说爱你，作于永州","text":"来不及说爱你，作于永州 来不及说爱你张翔相同的场景熟悉的身影却看不清你的脸只能追寻你的声音你说的昨天我留在今天忘记了你在身边回味你我相识片段时间划下了距离故意不说爱你默默放在心底转角泪水的哭泣想说爱你已来不及","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"开场白","slug":"开场白","date":"2012-01-23T03:06:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120123/开场白/","link":"","permalink":"https://tkvern.com/20120123/开场白/","excerpt":"开场白(初稿)，作于永州","text":"开场白(初稿)，作于永州 开场白张翔晨曦中醒来面对大海听到鱼儿的欢快你从家里出来我迫不及待洗脸刷牙打领带一路追你到站台你笑得那么可爱我追得那么蟋蟀别问我为什么追来只因为我想给你一段开场白是你的微笑让我有勇气表白把星星摘下来时光流逝依然还在是你的微笑","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"放不下","slug":"放不下","date":"2012-01-23T03:04:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120123/放不下/","link":"","permalink":"https://tkvern.com/20120123/放不下/","excerpt":"放下三部曲，第一部《放不下》，作于永州","text":"放下三部曲，第一部《放不下》，作于永州 放不下张翔手中的咖啡已经冷掉我的味蕾遗忘了那种味道你在路上做的记号我正努力寻找蓝色的大海走过多少你的发香风中还可以闻到你说分开似乎太早是我做得不好我放不下你已走得更远哭笑的瞬间深深藏在心里面我放不下你已走得更远我把你怀念留在回忆的昨天我又回到了从前","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"不想你难过","slug":"不想你难过","date":"2012-01-23T03:02:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20120123/不想你难过/","link":"","permalink":"https://tkvern.com/20120123/不想你难过/","excerpt":"不想你难过，作于永州","text":"不想你难过，作于永州 不想你难过张翔在你生病的时候我心里也会难过想不到该做些什么傻傻的不知所措你不开心的样子我看到会很心痛安慰的话该怎么说我思考了很多很多是我不想让你难过我要带你一起去看日落彩云在空中飘过告诉我未来多美好是我不想让你难过牵着你的手看星星闪烁当流星再次划过我陪你到海枯石沒","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"下锅","slug":"下锅","date":"2011-08-02T16:00:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20110802/下锅/","link":"","permalink":"https://tkvern.com/20110802/下锅/","excerpt":"随笔之作，打油诗，作于广州","text":"随笔之作，打油诗，作于广州 下锅张翔几多难过难以下锅思前想后菜成磋砣念剩饭还有几多方觉油盐尚存些许下锅 下锅把剩饭油盐齐下锅一番汗雨烟风一道电光火石三俩锹把饭来炒不多时只见烟雾袅袅有如仙境缥渺方神定 出锅","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"江畔","slug":"江畔","date":"2011-08-02T16:00:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20110802/江畔/","link":"","permalink":"https://tkvern.com/20110802/江畔/","excerpt":"江畔，作于广州","text":"江畔，作于广州 江畔张翔日落天际船只归去虹灯万彩路却难明细听风铃雨声响起此声延绵焉知我心忽闻笛鸣步履不前林边小道可有人行沉醉西风听瑟箫鼓谁人知晓生为何从","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"蹉跎","slug":"蹉跎","date":"2011-08-02T16:00:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20110802/蹉跎/","link":"","permalink":"https://tkvern.com/20110802/蹉跎/","excerpt":"蹉跎，作于广州","text":"蹉跎，作于广州 蹉跎张翔一两阵狂风卷过三两滴雨水飘落卷走的是落寞滴下的是难过问世间繁华几多只不过蜃楼海市为官禄年华磋砣又能留得住什么到垂髫方觉人生早已匆匆走过","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"中国的梦 我们的梦","slug":"中国的梦我们的梦","date":"2011-01-29T16:00:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20110129/中国的梦我们的梦/","link":"","permalink":"https://tkvern.com/20110129/中国的梦我们的梦/","excerpt":"中国的梦 我们的梦，作于永州","text":"中国的梦 我们的梦，作于永州 中国的梦 我们的梦张翔我们一直在执着自己的梦跌倒了 不会害怕又站起来 继续前行我们永远都坚持自己的梦受挫了 没有放弃擦干泪水 重新再来每一次失败都离成功更近一步我们一路走来再强的风 再大的雨 再多的坎我们仍然在放飞自己的梦想继续追寻为完成的梦自己的追求自己的梦千万个你我 编织了一个共同的梦我的梦 中国梦中国的梦 我们的梦我们一直在执着自己的梦失败了 不会气馁汲取经验 继续尝试我们永远都坚持自己的梦受伤了 没有哭泣擦掉忧伤 再站起来每一次尝试都离梦想更近一步我们一路走来多强的风 多大的雨 多高的坎我们依然在追寻自己的梦想继续实现未完成的梦我们的追求我们的梦千万个你我 编织了一个共同的梦我的梦 中国梦中国的梦 我们的梦","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"昨夜桂花香","slug":"昨夜桂花香","date":"2011-01-29T16:00:00.000Z","updated":"2023-01-20T15:23:47.000Z","comments":true,"path":"20110129/昨夜桂花香/","link":"","permalink":"https://tkvern.com/20110129/昨夜桂花香/","excerpt":"昨夜桂花香，作于永州","text":"昨夜桂花香，作于永州 昨夜桂花香张翔昨夜传来桂花香还带这一丝你的芬芳有你我不会觉得孤单就这样一直陪你到天亮昨夜闻到桂花香飘逸这一缕你的清淡要带我去到什么地方在这里不会有任何遗憾昨夜听到桂花唱流露这你对未来向往体会这歌声如此清凉在未来会有我和你相伴","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]},{"title":"一齐飞翔","slug":"一齐飞翔","date":"2010-07-25T16:00:00.000Z","updated":"2019-10-13T13:51:00.000Z","comments":true,"path":"20100725/一齐飞翔/","link":"","permalink":"https://tkvern.com/20100725/一齐飞翔/","excerpt":"一齐飞翔，作于永州，更新于东莞","text":"一齐飞翔，作于永州，更新于东莞 一齐飞翔作词 张翔作曲 编曲 混音 张东杰在这个秋季我们相遇在这里是缘分将你我捆在一起这注定是天意初不相识的我们却感觉 如此熟悉料不到我们将度过三年自信的我们 充满激情我们一起带着梦想乘着希望追寻未来无论风风雨雨我始终与你相伴不必害怕前路黑暗我们一起放飞青春的理想道不完我们三年的艰辛让我们张开翅膀 一齐飞翔又是个秋季我们重逢在这里是缘分将你我锁在一起这就是命运当初年少的我们还好像 停在昨天岁月抹不掉我们的足迹好想对你说 还记得吗我们一起带着梦想乘着希望追寻未来无论风风雨雨我依然与你相伴前路永远不会黑暗我们一起放飞青春的理想道不完我们三年的艰辛让我们张开翅膀 一齐飞翔","categories":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}],"tags":[],"keywords":[{"name":"诗词作品","slug":"诗词作品","permalink":"https://tkvern.com/categories/诗词作品/"}]}]}